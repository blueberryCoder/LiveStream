# 1 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 412 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.cpp" 2




# 1 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.h" 1







# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 1 3
# 106 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__config" 1 3
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__config" 3
# 215 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__config" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/features.h" 1 3 4
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/features.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/cdefs.h" 1 3 4
# 356 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/cdefs.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/versioning.h" 1 3 4
# 357 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/cdefs.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/api-level.h" 1 3 4
# 41 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/api-level.h" 3 4
extern "C" {
# 150 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/api-level.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/get_device_api_level_inlines.h" 1 3 4
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/get_device_api_level_inlines.h" 3 4
extern "C" {


int __system_property_get(const char* __name, char* __value);
int atoi(const char* __s) __attribute__((__pure__));

static inline int android_get_device_api_level() {
  char value[92] = { 0 };
  if (__system_property_get("ro.build.version.sdk", value) < 1) return -1;
  int api_level = atoi(value);
  return (api_level > 0) ? api_level : -1;
}

}
# 151 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/api-level.h" 2 3 4
# 166 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/api-level.h" 3 4
}
# 358 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/cdefs.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/ndk-version.h" 1 3 4
# 360 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/cdefs.h" 2 3 4
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/features.h" 2 3 4
# 216 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__config" 2 3
# 756 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__config" 3
namespace std { inline namespace __ndk1 { } }
# 107 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 2 3
# 110 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 3
# 123 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdint.h" 1 3
# 52 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdint.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdint.h" 1 3 4
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdint.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wchar_limits.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdint.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 1 3
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 3
typedef int ptrdiff_t;
# 46 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 3
typedef unsigned int size_t;
# 102 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/__stddef_max_align_t.h" 1 3
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 103 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 2 3
# 46 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 2 3



extern "C++" {

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__nullptr" 1 3
# 17 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__nullptr" 3
# 54 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 51 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 2 3
using std::nullptr_t;
}
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdint.h" 2 3 4


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;




typedef long long __int64_t;
typedef unsigned long long __uint64_t;






typedef int __intptr_t;
typedef unsigned int __uintptr_t;


typedef __int8_t int8_t;
typedef __uint8_t uint8_t;

typedef __int16_t int16_t;
typedef __uint16_t uint16_t;

typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;

typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;

typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef uint8_t uint_fast8_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;







typedef int32_t int_fast16_t;
typedef uint32_t uint_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast32_t;


typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 53 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdint.h" 2 3
# 124 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdint.h" 2 3
# 9 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.h" 2
# 1 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/IFLVTagData.h" 1







# 1 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/IBuffer.h" 1








class IBuffer {

public:
    virtual char *WriteTo(char *output) = 0;
    virtual int Size() = 0;

};
# 9 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/IFLVTagData.h" 2

typedef enum {
    ADPCM = 1,
    MP3 = 2,
    LINEAR_PCM_LITTLE_ENDIAN = 3,
    NELLYMOSER_16K_MONO = 4,
    NELLYMOSER_8K_MONO = 5,
    NELLYMOSER = 6,
    A_LAW_PCM = 7,
    MU_LAW_PCM = 8,
    RESERVED = 9,
    AAC = 10,
    SPEEX = 11,
    MP3_8_K = 14,
    DEVICE_SPECIFIC_SOUND = 15,
} AudioCodecId;

typedef AudioCodecId SoundFormat;

class IFLVTagData : public IBuffer {

};
# 10 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.h" 2

class FLVTag : IBuffer {

public:
    static constexpr int AUDIO = 8;
    static constexpr int VIDEO = 9;
    static constexpr int SCRIPT_DATA = 18;

    FLVTag(uint8_t tag_type,
           uint32_t data_size,
           uint32_t time_stamp,
           IFLVTagData *data
    );

    virtual ~FLVTag();
    char *WriteTo(char *output) override;
    int Size() override;

private :
    char buffer_[128];
    uint32_t size_;

    uint8_t tag_type_;
    uint32_t data_size_;
    uint32_t time_stamp_;
    IFLVTagData *data_;
};
# 6 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.cpp" 2
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 1 3
# 652 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 1 3
# 417 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstddef" 1 3
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstddef" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/version" 1 3
# 121 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/version" 3
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstddef" 2 3
# 41 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstddef" 3



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stddef.h" 1 3
# 45 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstddef" 2 3


namespace std { inline namespace __ndk1 {

using ::ptrdiff_t;
using ::size_t;




using ::max_align_t;




} }
# 418 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 2 3
# 422 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3


namespace std { inline namespace __ndk1 {

template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;


template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr operator value_type() const noexcept {return value;}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr value_type operator ()() const noexcept {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
# 456 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
typedef integral_constant<bool,(true)> true_type;
typedef integral_constant<bool,(false)> false_type;

template <bool _Val>
using _BoolConstant __attribute__((nodebug)) = integral_constant<bool, _Val>;

template <bool> struct _MetaBase;
template <>
struct _MetaBase<true> {
  template <class _Tp, class _Up>
  using _SelectImpl __attribute__((nodebug)) = _Tp;
  template <template <class...> class _FirstFn, template <class...> class, class ..._Args>
  using _SelectApplyImpl __attribute__((nodebug)) = _FirstFn<_Args...>;
  template <class _First, class...>
  using _FirstImpl __attribute__((nodebug)) = _First;
  template <class, class _Second, class...>
  using _SecondImpl __attribute__((nodebug)) = _Second;
  template <class _Tp = void>
  using _EnableIfImpl __attribute__((nodebug)) = _Tp;
  template <class _Result, class _First, class ..._Rest>
  using _OrImpl __attribute__((nodebug)) = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::template _OrImpl<_First, _Rest...>;
  template <class _Result, class _First, class ..._Rest>
  using _AndImpl __attribute__((nodebug)) = typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::template _AndImpl<_First, _Rest...>;
};

template <>
struct _MetaBase<false> {
  template <class _Tp, class _Up>
  using _SelectImpl __attribute__((nodebug)) = _Up;
  template <template <class...> class, template <class...> class _SecondFn, class ..._Args>
  using _SelectApplyImpl __attribute__((nodebug)) = _SecondFn<_Args...>;
  template <class _Result, class ...>
  using _OrImpl __attribute__((nodebug)) = _Result;
  template <class _Result, class ...>
  using _AndImpl __attribute__((nodebug)) = _Result;
};
template <bool _Cond, class _Ret = void>
using _EnableIf __attribute__((nodebug)) = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((nodebug)) = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
template <class ..._Rest>
using _Or __attribute__((nodebug)) = typename _MetaBase< sizeof...(_Rest) != 0 >::template _OrImpl<false_type, _Rest...>;
template <class ..._Rest>
using _And __attribute__((nodebug)) = typename _MetaBase< sizeof...(_Rest) != 0 >::template _AndImpl<true_type, _Rest...>;
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
template <class ..._Args>
using _FirstType __attribute__((nodebug)) = typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
template <class ..._Args>
using _SecondType __attribute__((nodebug)) = typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;

template <template <class...> class _Func, class ..._Args>
struct _Lazy : _Func<_Args...> {};



template <template <class...> class _Templ, class ..._Args>
true_type __sfinae_test_impl(_FirstType<int, _Templ<_Args...> >);
template <template <class...> class, class ...>
false_type __sfinae_test_impl(...);

template <template <class ...> class _Templ, class ..._Args>
using _IsValidExpansion __attribute__((nodebug)) = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;




template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};







template <class _Tp, class _Up>
using _IsSame = _BoolConstant<

    __is_same(_Tp, _Up)



>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<

    !__is_same(_Tp, _Up)



>;



template <class _Tp>
inline
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 639 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


struct __two {char __lx[2];};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};
# 659 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};
# 670 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;




template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
# 708 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 727 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};




template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
# 764 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
# 780 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};
# 795 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};
# 817 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&&> : public true_type {};
# 844 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 865 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 889 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public _BoolConstant<

    __is_function(_Tp)



    > {};
# 905 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_func > {};
# 932 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
 : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_member > {};
# 943 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public _BoolConstant< __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_obj > {};
# 956 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 983 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
# 995 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};
# 1008 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};
# 1025 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};
# 1039 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
# 1051 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const {
  typedef __attribute__((nodebug)) const _Tp type;
};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile {
  typedef __attribute__((nodebug)) volatile _Tp type;
};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv {
  typedef __attribute__((nodebug)) const volatile _Tp type;
};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef __attribute__((nodebug)) _Tp type;};


template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;




template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef __attribute__((nodebug)) _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef __attribute__((nodebug)) _Tp& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef __attribute__((nodebug)) typename __add_lvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef __attribute__((nodebug)) _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef __attribute__((nodebug)) _Tp&& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef __attribute__((nodebug)) typename __add_rvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;


template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);

template <class _Tp>
decltype(std::__ndk1::__declval<_Tp>(0))
declval() noexcept;



template <class _Tp>
struct __uncvref {
    typedef __attribute__((nodebug)) typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef __attribute__((nodebug)) typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t __attribute__((nodebug)) = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};
# 1161 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef __attribute__((nodebug)) _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef __attribute__((nodebug)) _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;




template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                _IsSame<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef __attribute__((nodebug)) _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef __attribute__((nodebug)) typename __add_pointer_impl<_Tp>::type type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
# 1203 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};
# 1224 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};
# 1245 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 1260 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
# 1279 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
# 1325 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Up, bool>
struct __decay {
    typedef __attribute__((nodebug)) typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef __attribute__((nodebug)) typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type _Up;
public:
    typedef __attribute__((nodebug)) typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
# 1372 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};
# 1402 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1416 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 1525 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1562 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1588 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1622 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};
# 1633 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             __fallback_overaligned<_Align>
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 1744 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};







template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,



    __nat



    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,



    __nat



    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef __attribute__((nodebug)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef __attribute__((nodebug)) typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef __attribute__((nodebug)) _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef __attribute__((nodebug)) const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;


template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};

template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
                          typename __void_t<decltype(
                                            true ? std::__ndk1::declval<_Tp>() : std::__ndk1::declval<_Up>()
                                            )>::type>
{
  typedef __attribute__((nodebug)) typename decay<decltype(
                         true ? std::__ndk1::declval<_Tp>() : std::__ndk1::declval<_Up>()
                         )>::type type;
};

template <class, class = void>
struct __common_type_impl {};




template <class... Tp>
struct __common_types;
template <class... _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type;
# 2067 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp , _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp , _Rest...> > {
};



template <>
struct __attribute__ ((__type_visibility__("default"))) common_type<> {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};



template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<
        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        __common_type2_imp<_Tp, _Up>,
        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
    >::type
{};



template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __attribute__ ((__type_visibility__("default")))
    common_type<_Tp, _Up, _Vp , _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp , _Rest...> > {};




template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;




template<typename, typename _Tp> struct __select_2nd { typedef __attribute__((nodebug)) _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__ndk1::declval<_Tp>() = std::__ndk1::declval<_Arg>())), true_type>::type
__is_assignable_test(int);

template <class, class>
false_type __is_assignable_test(...);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__ndk1::__is_assignable_test<_Tp, _Arg>(0))) {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};
# 2153 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2165 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};
# 2184 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__ndk1::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__ndk1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__ndk1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__ndk1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__ndk1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__ndk1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__ndk1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__ndk1::false_type {};

template <>
struct is_destructible<void>
    : public std::__ndk1::false_type {};
# 2241 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "can not forward an rvalue as an lvalue");
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__ndk1::forward<_Tp>(__t);
}

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};



template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};



template <class _Callable> class result_of;
# 2659 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
namespace __is_construct
{
struct __nat {};
}
# 2781 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};
# 2799 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};
# 2812 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2825 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 2840 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 2893 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};
# 2905 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};
# 2917 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 2931 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2969 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2981 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
# 2996 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 3028 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 3080 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};
# 3092 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3104 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};
# 3118 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
# 3154 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3166 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};
# 3181 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__ndk1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3244 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3265 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {};
# 3277 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};
# 3293 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};
# 3311 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};







template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};



template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 3401 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...)) { return (std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...)) { return (std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...)) { return ((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...)) { return ((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__ndk1::forward<_A0>(__a0).*__f)) -> decltype(std::__ndk1::forward<_A0>(__a0).*__f) { return std::__ndk1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__ndk1::forward<_A0>(__a0).*__f)) -> decltype(std::__ndk1::forward<_A0>(__a0).*__f) { return std::__ndk1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__ndk1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__ndk1::forward<_A0>(__a0)).*__f) { return (*std::__ndk1::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__ndk1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__ndk1::forward<_A0>(__a0)).*__f) { return (*std::__ndk1::forward<_A0>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...)) { return std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...))) -> decltype(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...)) { return std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...); }




template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
  template <class _XFp, class ..._XArgs>
  static auto __try_call(int) -> decltype(
    std::__ndk1::__invoke(std::__ndk1::declval<_XFp>(), std::__ndk1::declval<_XArgs>()...));
  template <class _XFp, class ..._XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type =
  typename conditional<
      _IsNotSame<_Result, __nat>::value,
      typename conditional<
          is_void<_Ret>::value,
          true_type,
          is_convertible<_Result, _Ret>
      >::type,
      false_type
  >::type;
  static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__ndk1::__invoke(std::__ndk1::declval<_Fp>(), std::__ndk1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__ndk1::__invoke(std::__ndk1::declval<_Fp>(), std::__ndk1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};



template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};


template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
# 3652 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type




swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__ndk1::move(__x));
    __x = std::__ndk1::move(__y);
    __y = std::__ndk1::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

               noexcept(noexcept(swap(*std::__ndk1::declval<_ForwardIterator1>(), *std::__ndk1::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}



namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__ndk1::declval<_LHS>(), std::__ndk1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = _IsNotSame<__swap1, __nat>::value
                           && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__ndk1::declval<_Tp>(), std::__ndk1::declval<_Up>()))
  && noexcept(swap(std::__ndk1::declval<_Up>(), std::__ndk1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
# 3804 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;



template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }

template<typename _Fp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) { return __val; }
# 3864 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__ndk1::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__ndk1::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
# 3928 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
# 3967 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/type_traits" 3
inline constexpr
bool __libcpp_is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }





template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

} }
# 653 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 1 3
# 60 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/exception" 1 3
# 81 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/exception" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdlib" 1 3
# 85 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdlib" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 1 3
# 95 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/stdlib.h" 1 3
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/stdlib.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 1 3 4
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/alloca.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wait.h" 1 3 4
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wait.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/wait.h" 1 3 4
# 39 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wait.h" 2 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 1 3 4
# 29 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 30 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdio.h" 1 3 4
# 105 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdio.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 1 3 4
# 42 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 1 3 4
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 2 3 4



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/types.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/types.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/int-ll64.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/bitsperlong.h" 1 3 4
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/bitsperlong.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/bitsperlong.h" 2 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/int-ll64.h" 2 3 4

typedef __signed__ char __s8;
typedef unsigned char __u8;
typedef __signed__ short __s16;
typedef unsigned short __u16;
typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/types.h" 2 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/types.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/posix_types.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/posix_types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/stddef.h" 1 3 4
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/stddef.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/compiler_types.h" 1 3 4




# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/compiler.h" 1 3 4
# 6 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/compiler_types.h" 2 3 4
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/stddef.h" 2 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/posix_types.h" 2 3 4


typedef struct {
  unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;
typedef void(* __kernel_sighandler_t) (int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/posix_types.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/posix_types.h" 3 4
typedef unsigned short __kernel_mode_t;

typedef unsigned short __kernel_ipc_pid_t;

typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;

typedef unsigned short __kernel_old_dev_t;


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/posix_types.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/posix_types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/bitsperlong.h" 1 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/posix_types.h" 2 3 4

typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;


typedef __kernel_ulong_t __kernel_ino_t;





typedef int __kernel_pid_t;
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_long_t __kernel_suseconds_t;


typedef int __kernel_daddr_t;


typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;


typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;






typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;







typedef struct {
  int val[2];
} __kernel_fsid_t;

typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 31 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/posix_types.h" 2 3 4
# 31 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/posix_types.h" 2 3 4
# 24 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/types.h" 2 3 4


typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;



typedef unsigned __poll_t;
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/pthread_types.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/pthread_types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/pthread_types.h" 2 3 4

typedef struct {
  uint32_t flags;
  void* stack_base;
  size_t stack_size;
  size_t guard_size;
  int32_t sched_policy;
  int32_t sched_priority;



} pthread_attr_t;
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/pthread_types.h" 3 4
typedef struct {



  int32_t __private[1];

} pthread_cond_t;

typedef long pthread_condattr_t;

typedef int pthread_key_t;

typedef struct {



  int32_t __private[1];

} pthread_mutex_t;

typedef long pthread_mutexattr_t;

typedef int pthread_once_t;

typedef struct {



  int32_t __private[10];

} pthread_rwlock_t;

typedef long pthread_rwlockattr_t;
# 105 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/pthread_types.h" 3 4
typedef long pthread_t;
# 40 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 2 3 4


typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint64_t ino64_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;



typedef uint32_t dev_t;





typedef __kernel_time_t __time_t;
typedef __time_t time_t;
# 105 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 3 4
typedef __kernel_off_t off_t;
typedef __kernel_loff_t loff_t;
typedef loff_t off64_t;




typedef int32_t __socklen_t;




typedef __socklen_t socklen_t;

typedef __builtin_va_list __va_list;
# 128 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/types.h" 3 4
typedef __kernel_ssize_t ssize_t;


typedef unsigned int uint_t;
typedef unsigned int uint;


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdarg.h" 1 3 4
# 14 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 45 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 46 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/seek_constants.h" 1 3 4
# 48 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/struct_file.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/struct_file.h" 3 4
extern "C" {


struct __sFILE {



  char __private[84];

} __attribute__((aligned(sizeof(void*))));

}
# 51 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4


extern "C" {

typedef off_t fpos_t;
typedef off64_t fpos64_t;

struct __sFILE;
typedef struct __sFILE FILE;
# 72 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
extern FILE __sF[] __attribute__((annotate("obsoleted_in=" "23")));
# 106 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
void clearerr(FILE* __fp);
int fclose(FILE* __fp);
int feof(FILE* __fp);
int ferror(FILE* __fp);
int fflush(FILE* __fp);
int fgetc(FILE* __fp);
char* fgets(char* __buf, int __size, FILE* __fp);
int fprintf(FILE* __fp , const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
int fputc(int __ch, FILE* __fp);
int fputs(const char* __s, FILE* __fp);
size_t fread(void* __buf, size_t __size, size_t __count, FILE* __fp);
int fscanf(FILE* __fp, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
size_t fwrite(const void* __buf, size_t __size, size_t __count, FILE* __fp);
int getc(FILE* __fp);
int getchar(void);







void perror(const char* __msg);
int printf(const char* __fmt, ...) __attribute__((__format__(printf, 1, 2)));
int putc(int __ch, FILE* __fp);
int putchar(int __ch);
int puts(const char* __s);
int remove(const char* __path);
void rewind(FILE* __fp);
int scanf(const char* __fmt, ...) __attribute__((__format__(scanf, 1, 2)));
void setbuf(FILE* __fp, char* __buf);
int setvbuf(FILE* __fp, char* __buf, int __mode, size_t __size);
int sscanf(const char* __s, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
int ungetc(int __ch, FILE* __fp);
int vfprintf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
int vprintf(const char* __fp, va_list __args) __attribute__((__format__(printf, 1, 0)));
# 154 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
int dprintf(int __fd, const char* __fmt, ...) __asm__("fdprintf") __attribute__((__format__(printf, 2, 3)));
int vdprintf(int __fd, const char* __fmt, va_list __args) __asm__("vfdprintf") __attribute__((__format__(printf, 2, 0)));






int sprintf(char* __s, const char* __fmt, ...)
    __attribute__((__format__(printf, 2, 3))) ;
int vsprintf(char* __s, const char* __fmt, va_list __args)
    __attribute__((__format__(printf, 2, 0))) ;
char* tmpnam(char* __s)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));

char* tempnam(const char* __dir, const char* __prefix)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));







int rename(const char* __old_path, const char* __new_path);







int renameat(int __old_dir_fd, const char* __old_path, int __new_dir_fd, const char* __new_path);
# 223 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
int fseek(FILE* __fp, long __offset, int __whence);
long ftell(FILE* __fp);
# 248 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
int fgetpos(FILE* __fp, fpos_t* __pos);
int fsetpos(FILE* __fp, const fpos_t* __pos);
int fseeko(FILE* __fp, off_t __offset, int __whence);
off_t ftello(FILE* __fp);

FILE* funopen(const void* __cookie,
              int (*__read_fn)(void*, char*, int),
              int (*__write_fn)(void*, const char*, int),
              fpos_t (*__seek_fn)(void*, fpos_t, int),
              int (*__close_fn)(void*));
# 280 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
FILE* fopen(const char* __path, const char* __mode);





FILE* freopen(const char* __path, const char* __mode, FILE* __fp);





FILE* tmpfile(void);






int snprintf(char* __buf, size_t __size, const char* __fmt, ...) __attribute__((__format__(printf, 3, 4)));
int vfscanf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
int vscanf(const char* __fmt , va_list __args) __attribute__((__format__(scanf, 1, 0)));
int vsnprintf(char* __buf, size_t __size, const char* __fmt, va_list __args) __attribute__((__format__(printf, 3, 0)));
int vsscanf(const char* __s, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
# 312 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
FILE* fdopen(int __fd, const char* __mode);
int fileno(FILE* __fp);
int pclose(FILE* __fp);
FILE* popen(const char* __command, const char* __mode);
void flockfile(FILE* __fp);
int ftrylockfile(FILE* __fp);
void funlockfile(FILE* __fp);
int getc_unlocked(FILE* __fp);
int getchar_unlocked(void);
int putc_unlocked(int __ch, FILE* __fp);
int putchar_unlocked(int __ch);
# 332 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
int asprintf(char** __s_ptr, const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
char* fgetln(FILE* __fp, size_t* __length_ptr);
int fpurge(FILE* __fp);
void setbuffer(FILE* __fp, char* __buf, int __size);
int setlinebuf(FILE* __fp);
int vasprintf(char** __s_ptr, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
# 376 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 1 3 4
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 3 4
static __attribute__((unused))
int sprintf(char* dest, const char* format)
    __attribute__((overloadable))
    __attribute__((enable_if(((__builtin_object_size(((dest)), (1))) != ((size_t) -1) && (__builtin_object_size(((dest)), (1))) < (__builtin_strlen(format))), "format string will always overflow destination buffer")))

    __attribute__((unavailable("format string will always overflow destination buffer")));
# 94 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 3 4
static __inline__ __attribute__((__always_inline__))
size_t fread(void* const __attribute__((pass_object_size(0))) buf, size_t size, size_t count, FILE* stream)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((unsigned int)-1 / (size) < (count)), "in call to 'fread', size * count overflows", "error")))

        __attribute__((diagnose_if(((__builtin_object_size(((buf)), (0))) != ((size_t) -1) && (__builtin_object_size(((buf)), (0))) < (size * count)), "in call to 'fread', size * count is too large for the given buffer", "error"))) {
# 108 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 3 4
    return (&fread)(buf, size, count, stream);
}

static __inline__ __attribute__((__always_inline__))
size_t fwrite(const void* const __attribute__((pass_object_size(0))) buf, size_t size, size_t count, FILE* stream)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((unsigned int)-1 / (size) < (count)), "in call to 'fwrite', size * count overflows", "error")))

        __attribute__((diagnose_if(((__builtin_object_size(((buf)), (0))) != ((size_t) -1) && (__builtin_object_size(((buf)), (0))) < (size * count)), "in call to 'fwrite', size * count is too large for the given buffer", "error"))) {
# 125 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 3 4
    return (&fwrite)(buf, size, count, stream);
}


static __inline__ __attribute__((__always_inline__))
char* fgets(char* const __attribute__((pass_object_size(1))) dest, int size, FILE* stream)
        __attribute__((overloadable))
        __attribute__((diagnose_if(size < 0, "in call to 'fgets', size should not be negative", "error")))
        __attribute__((diagnose_if(((__builtin_object_size(((dest)), (1))) != ((size_t) -1) && (__builtin_object_size(((dest)), (1))) < (size)), "in call to 'fgets', size is larger than the destination buffer", "error"))) {
# 142 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdio.h" 3 4
    return (&fgets)(dest, size, stream);
}
# 377 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdio.h" 2 3 4


}
# 108 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdio.h" 2 3
# 31 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 2 3 4

extern "C" {
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
void* malloc(size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(1))) __attribute__((__warn_unused_result__));
# 52 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
void* calloc(size_t __item_count, size_t __item_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2))) __attribute__((__warn_unused_result__));
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
void* realloc(void* __ptr, size_t __byte_count) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
# 83 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
void free(void* __ptr);
# 94 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
void* memalign(size_t __alignment, size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
# 110 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
struct mallinfo {

  size_t arena;

  size_t ordblks;

  size_t smblks;

  size_t hblks;

  size_t hblkhd;

  size_t usmblks;

  size_t fsmblks;

  size_t uordblks;

  size_t fordblks;

  size_t keepcost;
};







struct mallinfo mallinfo(void);
# 248 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/malloc.h" 3 4
}
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/xlocale.h" 1 3 4
# 44 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/xlocale.h" 3 4
struct __locale_t;




typedef struct __locale_t* locale_t;
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4

extern "C" {




__attribute__((__noreturn__)) void abort(void);
__attribute__((__noreturn__)) void exit(int __status);



__attribute__((__noreturn__)) void _Exit(int) __asm__("_exit");


int atexit(void (*__fn)(void));
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
char* getenv(const char* __name);
int putenv(char* __assignment);
int setenv(const char* __name, const char* __value, int __overwrite);
int unsetenv(const char* __name);
int clearenv(void);

char* mkdtemp(char* __template);
char* mktemp(char* __template) __attribute__((deprecated("mktemp is unsafe, use mkstemp or tmpfile instead")));
# 83 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
int mkstemp(char* __template);





int mkstemps(char* __template, int __flags);

long strtol(const char* __s, char** __end_ptr, int __base);
long long strtoll(const char* __s, char** __end_ptr, int __base);
unsigned long strtoul(const char* __s, char** __end_ptr, int __base);
unsigned long long strtoull(const char* __s, char** __end_ptr, int __base);
# 108 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
double strtod(const char* __s, char** __end_ptr);
long double strtold(const char* __s, char** __end_ptr) __asm__("strtod") __attribute__((annotate("introduced_in=" "3")));







int atoi(const char* __s) __attribute__((__pure__));
long atol(const char* __s) __attribute__((__pure__));
long long atoll(const char* __s) __attribute__((__pure__));

__attribute__((__warn_unused_result__)) char* realpath(const char* __path, char* __resolved);
int system(const char* __command);

void* bsearch(const void* __key, const void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

void qsort(void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

uint32_t arc4random(void);
uint32_t arc4random_uniform(uint32_t __upper_bound);
void arc4random_buf(void* __buf, size_t __n);
# 140 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
double drand48(void);
double erand48(unsigned short __xsubi[3]);
long jrand48(unsigned short __xsubi[3]);





long lrand48(void);
long mrand48(void);
long nrand48(unsigned short __xsubi[3]);
unsigned short* seed48(unsigned short __seed16v[3]);
void srand48(long __seed);
# 161 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
int getpt(void);





char* ptsname(int __fd);
int ptsname_r(int __fd, char* __buf, size_t __n);
int unlockpt(int __fd);







typedef struct {
  int quot;
  int rem;
} div_t;

div_t div(int __numerator, int __denominator) __attribute__((__const__));

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

ldiv_t ldiv(long __numerator, long __denominator) __attribute__((__const__));

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

lldiv_t lldiv(long long __numerator, long long __denominator) __attribute__((__const__));
# 219 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
int mblen(const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "26"))) __attribute__((annotate("versioner_no_guard")));
size_t mbstowcs(wchar_t* __dst, const char* __src, size_t __n);
int mbtowc(wchar_t* __wc_ptr, const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));
int wctomb(char* __dst, wchar_t __wc) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));

size_t wcstombs(char* __dst, const wchar_t* __src, size_t __n);
# 239 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdlib.h" 1 3 4
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/stdlib.h" 3 4
char* realpath(const char* path, char* resolved)
        __attribute__((diagnose_if(!path, "'realpath': NULL path is never correct; flipped arguments?", "error")))
        __attribute__((diagnose_if(((__builtin_object_size(((resolved)), (1))) != ((size_t) -1) && (__builtin_object_size(((resolved)), (1))) < (4096)), "'realpath' output parameter must be NULL or a pointer to a buffer " "with >= PATH_MAX bytes", "error")));
# 240 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4
# 274 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 3 4
}


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 1 3 4
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 3 4
extern "C" {

static inline int abs(int __n) { return (__n < 0) ? -__n : __n; }

static inline long labs(long __n) { return (__n < 0L) ? -__n : __n; }

static inline long long llabs(long long __n) {
  return (__n < 0LL) ? -__n : __n;
}

}






# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/errno.h" 1 3 4
# 29 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/errno.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/errno.h" 1 3 4
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/errno.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/errno.h" 1 3 4
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/errno.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/errno.h" 1 3 4
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/errno.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/errno.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/errno.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/errno-base.h" 1 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/errno.h" 2 3 4
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/errno.h" 2 3 4
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/errno.h" 2 3 4
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/errno.h" 2 3 4

extern "C" {
# 52 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/errno.h" 3 4
int* __errno(void) __attribute__((__const__));







}


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_errno_inlines.h" 1 3 4
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_errno_inlines.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/errno.h" 1 3 4
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_errno_inlines.h" 2 3 4

extern "C" {

static inline int __attribute__((deprecated)) __set_errno(int n) {
  (*__errno()) = n;
  return -1;
}

}
# 63 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/errno.h" 2 3 4
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/errno.h" 2 3
# 53 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/float.h" 1 3 4
# 77 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/float.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/float.h" 1 3
# 80 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/float.h" 2 3
# 54 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 1 3 4
# 55 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 2 3 4

extern "C" {

static inline float strtof(const char* nptr, char** endptr) {
  double d = strtod(nptr, endptr);
  if (d > 3.40282347e+38F) {
    (*__errno()) = 34;
    return __builtin_huge_valf();
  } else if (d < -3.40282347e+38F) {
    (*__errno()) = 34;
    return -__builtin_huge_valf();
  }
  return (static_cast<float>(d));
}

static inline double atof(const char *nptr) { return (strtod(nptr, __null)); }

static inline int rand(void) { return (int)lrand48(); }

static inline void srand(unsigned int __s) { srand48(__s); }

static inline long random(void) { return lrand48(); }

static inline void srandom(unsigned int __s) { srand48(__s); }

static inline int grantpt(int __fd __attribute((unused))) {
  return 0;
}

}






# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 1 3 4
# 91 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_stdlib_inlines.h" 2 3 4


extern "C" {

static inline double strtod_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtod(__s, __end_ptr);
}

static inline float strtof_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtof(__s, __end_ptr);
}

static inline long strtol_l(const char* __s, char** __end_ptr, int __base, locale_t __l) {
  return strtol(__s, __end_ptr, __base);
}

}
# 277 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/stdlib.h" 2 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/stdlib.h" 2 3

extern "C" {


int posix_memalign(void** memptr, size_t alignment, size_t size);



long double strtold_l(const char*, char**, locale_t);
long long strtoll_l(const char*, char**, int, locale_t);
unsigned long long strtoull_l(const char*, char**, int, locale_t);
int mbtowc(wchar_t*, const char*, size_t);
int at_quick_exit(void (*)(void));
void quick_exit(int) __attribute__((__noreturn__));


}
# 98 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 2 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 1 3
# 298 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 1 3
# 14 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 3
# 302 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/math.h" 1 3
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/math.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits.h" 1 3 4
# 44 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits.h" 3
# 57 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/limits.h" 1 3
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/limits.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/limits.h" 1 3 4
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/limits.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/limits.h" 1 3 4
# 44 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/limits.h" 2 3 4
# 140 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/limits.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/posix_limits.h" 1 3 4
# 141 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/limits.h" 2 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/9.0.9/include/limits.h" 2 3
# 58 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits.h" 2 3
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 2 3 4

extern "C" {



typedef double __double_t;
typedef __double_t double_t;
typedef float __float_t;
typedef __float_t float_t;
# 78 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
double acos(double __x);
float acosf(float __x);
long double acosl(long double __x) __asm__("acos") __attribute__((annotate("introduced_in=" "3")));

double asin(double __x);
float asinf(float __x);
long double asinl(long double __x) __asm__("asin") __attribute__((annotate("introduced_in=" "3")));

double atan(double __x);
float atanf(float __x);
long double atanl(long double __x) __asm__("atan") __attribute__((annotate("introduced_in=" "3")));

double atan2(double __y, double __x);
float atan2f(float __y, float __x);
long double atan2l(long double __y, long double __x) __asm__("atan2") __attribute__((annotate("introduced_in=" "3")));

double cos(double __x);
float cosf(float __x);
long double cosl(long double __x) __asm__("cos") __attribute__((annotate("introduced_in=" "3")));

double sin(double __x);
float sinf(float __x);
long double sinl(long double __x) __asm__("sin") __attribute__((annotate("introduced_in=" "3")));

double tan(double __x);
float tanf(float __x);
long double tanl(long double __x) __asm__("tan") __attribute__((annotate("introduced_in=" "3")));

double acosh(double __x);
float acoshf(float __x);
long double acoshl(long double __x) __asm__("acosh") __attribute__((annotate("introduced_in=" "3")));

double asinh(double __x);
float asinhf(float __x);
long double asinhl(long double __x) __asm__("asinh") __attribute__((annotate("introduced_in=" "3")));

double atanh(double __x);
float atanhf(float __x);
long double atanhl(long double __x) __asm__("atanh") __attribute__((annotate("introduced_in=" "3")));

double cosh(double __x);
float coshf(float __x);
long double coshl(long double __x) __asm__("cosh") __attribute__((annotate("introduced_in=" "3")));

double sinh(double __x);
float sinhf(float __x);
long double sinhl(long double __x) __asm__("sinh") __attribute__((annotate("introduced_in=" "3")));

double tanh(double __x);
float tanhf(float __x);
long double tanhl(long double __x) __asm__("tanh") __attribute__((annotate("introduced_in=" "3")));

double exp(double __x);
float expf(float __x);
long double expl(long double __x) __asm__("exp") __attribute__((annotate("introduced_in=" "3")));

double exp2(double __x);
float exp2f(float __x);
long double exp2l(long double __x) __asm__("exp2") __attribute__((annotate("introduced_in=" "3")));

double expm1(double __x);
float expm1f(float __x);
long double expm1l(long double __x) __asm__("expm1") __attribute__((annotate("introduced_in=" "3")));

double frexp(double __x, int* __exponent);
float frexpf(float __x, int* __exponent);
long double frexpl(long double __x, int* __exponent) __asm__("frexp") __attribute__((annotate("introduced_in=" "3")));

int ilogb(double __x) __attribute__((__const__));
int ilogbf(float __x) __attribute__((__const__));
int ilogbl(long double __x) __asm__("ilogb") __attribute__((annotate("introduced_in=" "3"))) __attribute__((__const__));

double ldexp(double __x, int __exponent);
float ldexpf(float __x, int __exponent);
long double ldexpl(long double __x, int __exponent) __asm__("ldexp") __attribute__((annotate("introduced_in=" "3")));

double log(double __x);
float logf(float __x);
long double logl(long double __x) __asm__("log") __attribute__((annotate("introduced_in=" "3")));

double log10(double __x);
float log10f(float __x);
long double log10l(long double __x) __asm__("log10") __attribute__((annotate("introduced_in=" "3")));

double log1p(double __x);
float log1pf(float __x);
long double log1pl(long double __x) __asm__("log1p") __attribute__((annotate("introduced_in=" "3")));
# 174 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
double logb(double __x);
float logbf(float __x);
long double logbl(long double __x) __asm__("logb") __attribute__((annotate("introduced_in=" "3")));

double modf(double __x, double* __integral_part);
float modff(float __x, float* __integral_part);
long double modfl(long double __x, long double* __integral_part) __asm__("modf") __attribute__((annotate("introduced_in=" "3")));

double scalbn(double __x, int __exponent);
float scalbnf(float __x, int __exponent);
long double scalbnl(long double __x, int __exponent) __asm__("scalbn") __attribute__((annotate("introduced_in=" "3")));


double scalbln(double __x, long __exponent) __attribute__((annotate("introduced_in_x86=" "18"))) __attribute__((annotate("versioner_no_guard")));
float scalblnf(float __x, long __exponent) __attribute__((annotate("introduced_in_x86=" "18"))) __attribute__((annotate("versioner_no_guard")));
long double scalblnl(long double __x, long __exponent) __attribute__((annotate("introduced_in_x86=" "18"))) __attribute__((annotate("versioner_no_guard")));

double cbrt(double __x);
float cbrtf(float __x);
long double cbrtl(long double __x) __asm__("cbrt") __attribute__((annotate("introduced_in=" "3")));

double fabs(double __x) __attribute__((__const__));
float fabsf(float __x) __attribute__((__const__));
long double fabsl(long double __x) __asm__("fabs") __attribute__((annotate("introduced_in=" "3"))) __attribute__((__const__));

double hypot(double __x, double __y);
float hypotf(float __x, float __y);
long double hypotl(long double __x, long double __y) __asm__("hypot") __attribute__((annotate("introduced_in=" "3")));

double pow(double __x, double __y);
float powf(float __x, float __y);
long double powl(long double __x, long double __y) __asm__("pow") __attribute__((annotate("introduced_in=" "3")));

double sqrt(double __x);
float sqrtf(float __x);
long double sqrtl(long double __x) __asm__("sqrt") __attribute__((annotate("introduced_in=" "3")));

double erf(double __x);
float erff(float __x);
long double erfl(long double __x) __asm__("erf") __attribute__((annotate("introduced_in=" "3")));

double erfc(double __x);
float erfcf(float __x);
long double erfcl(long double __x) __asm__("erfc") __attribute__((annotate("introduced_in=" "3")));

double lgamma(double __x);
float lgammaf(float __x);
long double lgammal(long double __x) __asm__("lgamma") __attribute__((annotate("introduced_in=" "3")));

double tgamma(double __x);
float tgammaf(float __x);
long double tgammal(long double __x) __asm__("tgamma") __attribute__((annotate("introduced_in=" "3")));

double ceil(double __x);
float ceilf(float __x);
long double ceill(long double __x) __asm__("ceil") __attribute__((annotate("introduced_in=" "3")));

double floor(double __x);
float floorf(float __x);
long double floorl(long double __x) __asm__("floor") __attribute__((annotate("introduced_in=" "3")));

double nearbyint(double __x);
float nearbyintf(float __x);
long double nearbyintl(long double __x) __asm__("nearbyint") __attribute__((annotate("introduced_in=" "3")));

double rint(double __x);
float rintf(float __x);
long double rintl(long double __x) __asm__("rint") __attribute__((annotate("introduced_in=" "3")));

long lrint(double __x);
long lrintf(float __x);
long lrintl(long double __x) __asm__("lrint") __attribute__((annotate("introduced_in=" "3")));

long long llrint(double __x);
long long llrintf(float __x);
long long llrintl(long double __x) __asm__("llrint") __attribute__((annotate("introduced_in=" "3")));

double round(double __x);
float roundf(float __x);
long double roundl(long double __x) __asm__("roundl") __attribute__((annotate("introduced_in=" "3")));

long lround(double __x);
long lroundf(float __x);
long lroundl(long double __x) __asm__("lround") __attribute__((annotate("introduced_in=" "3")));

long long llround(double __x);
long long llroundf(float __x);
long long llroundl(long double __x) __asm__("llround") __attribute__((annotate("introduced_in=" "3")));

double trunc(double __x);
float truncf(float __x);
long double truncl(long double __x) __asm__("trunc") __attribute__((annotate("introduced_in=" "3")));

double fmod(double __x, double __y);
float fmodf(float __x, float __y);
long double fmodl(long double __x, long double __y) __asm__("fmod") __attribute__((annotate("introduced_in=" "3")));

double remainder(double __x, double __y);
float remainderf(float __x, float __y);
long double remainderl(long double __x, long double __y) __asm__("remainder") __attribute__((annotate("introduced_in=" "3")));

double remquo(double __x, double __y, int* __quotient_bits);
float remquof(float __x, float __y, int* __quotient_bits);
long double remquol(long double __x, long double __y, int* __quotient_bits) __asm__("remquo") __attribute__((annotate("introduced_in=" "3")));

double copysign(double __value, double __sign) __attribute__((__const__));
float copysignf(float __value, float __sign) __attribute__((__const__));
long double copysignl(long double __value, long double __sign) __asm__("copysign") __attribute__((annotate("introduced_in=" "3"))) __attribute__((__const__));

double nan(const char* __kind) __attribute__((__const__));
float nanf(const char* __kind) __attribute__((__const__));
long double nanl(const char* __kind) __asm__("nan") __attribute__((annotate("introduced_in=" "13"))) __attribute__((__const__));

double nextafter(double __x, double __y);
float nextafterf(float __x, float __y);
long double nextafterl(long double __x, long double __y) __asm__("nextafter") __attribute__((annotate("introduced_in=" "3"))) __attribute__((annotate("versioner_no_guard")));

double nexttoward(double __x, long double __y) __attribute__((annotate("introduced_in=" "18"))) __attribute__((annotate("versioner_no_guard")));
float nexttowardf(float __x, long double __y);
long double nexttowardl(long double __x, long double __y) __asm__("nexttoward") __attribute__((annotate("introduced_in=" "18"))) __attribute__((annotate("versioner_no_guard")));

double fdim(double __x, double __y);
float fdimf(float __x, float __y);
long double fdiml(long double __x, long double __y) __asm__("fdim") __attribute__((annotate("introduced_in=" "3")));

double fmax(double __x, double __y) __attribute__((__const__));
float fmaxf(float __x, float __y) __attribute__((__const__));
long double fmaxl(long double __x, long double __y) __asm__("fmax") __attribute__((annotate("introduced_in=" "3"))) __attribute__((__const__));

double fmin(double __x, double __y) __attribute__((__const__));
float fminf(float __x, float __y) __attribute__((__const__));
long double fminl(long double __x, long double __y) __asm__("fmin") __attribute__((annotate("introduced_in=" "3"))) __attribute__((__const__));

double fma(double __x, double __y, double __z);
float fmaf(float __x, float __y, float __z);
long double fmal(long double __x, long double __y, long double __z) __asm__("fma") __attribute__((annotate("introduced_in=" "3"))) __attribute__((annotate("versioner_no_guard")));
# 334 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
int (isnan)(double __x) __attribute__((__const__));



extern int signgam;

double j0(double __x);
double j1(double __x);
double jn(int __n, double __x);
double y0(double __x);
double y1(double __x);
double yn(int __n, double __x);
# 372 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
double gamma(double __x);
double scalb(double __x, double __exponent);
double drem(double __x, double __y);
int finite(double __x) __attribute__((__const__));
int isnanf(float __x) __attribute__((__const__));
double gamma_r(double __x, int* __sign);
double lgamma_r(double __x, int* __sign);
double significand(double __x);
# 390 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
float dremf(float __x, float __y);
int finitef(float __x) __attribute__((__const__));
float gammaf(float __x);
float j0f(float __x);
float j1f(float __x);
float jnf(int __n, float __x);
float scalbf(float __x, float __exponent);
float y0f(float __x);
float y1f(float __x);
float ynf(int __n, float __x);
float gammaf_r(float __x, int* __sign);
float lgammaf_r(float __x, int* __sign);
float significandf(float __x);
void sincos(double __x, double* __sin, double* __cos);
void sincosf(float __x, float* __sin, float* __cos);
void sincosl(long double __x, long double* __sin, long double* __cos);
# 426 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/math.h" 3 4
}
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/math.h" 2 3

extern "C" {


double log2(double);
float log2f(float);
long double log2l(long double);
long double logbl(long double);
float tgammaf(float);



long double acoshl(long double);
long double acosl(long double);
long double asinhl(long double);
long double asinl(long double);
long double atan2l(long double, long double);
long double atanhl(long double);
long double atanl(long double);
long double cbrtl(long double);
long double coshl(long double);
long double cosl(long double);
long double erfcl(long double);
long double erfl(long double);
long double exp2l(long double);
long double expl(long double);
long double expm1l(long double);
long double fmodl(long double, long double);
long double hypotl(long double, long double);
long double lgammal(long double);
long double log10l(long double);
long double log1pl(long double);
long double logl(long double);
long double modfl(long double, long double*);
long double nearbyintl(long double);
long double powl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int*);
long double rintl(long double);
long double sinhl(long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanhl(long double);
long double tanl(long double);
long double tgammal(long double);
long int lrintl(long double);
long long int llrintl(long double);


}
# 304 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 2 3





extern "C++" {



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits" 1 3
# 117 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits" 3



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/limits" 2 3



namespace std { inline namespace __ndk1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__ndk1::is_signed<_Tp>::value;





    static constexpr const bool traps = false;

    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5L;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 313 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 2 3





template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_signbit(_A1 __lcpp_x) noexcept
{
    return ((sizeof(__lcpp_x) == sizeof(float)) ? __builtin_signbitf(__lcpp_x) : (sizeof(__lcpp_x) == sizeof(double)) ? __builtin_signbit(__lcpp_x) : __builtin_signbitl(__lcpp_x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{ return __lcpp_x < 0; }

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
signbit(_A1) noexcept
{ return false; }
# 380 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept
{
    return __builtin_fpclassify(0x02, 0x01, 0x04, 0x08, 0x10, __lcpp_x);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{ return __lcpp_x == 0 ? 0x10 : 0x04; }
# 426 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept
{
    return __builtin_isfinite(__lcpp_x);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1 __lcpp_x) noexcept
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1) noexcept
{ return true; }







template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isinf(_A1 __lcpp_x) noexcept
{
    return __builtin_isinf(__lcpp_x);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1 __lcpp_x) noexcept
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1) noexcept
{ return false; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isinf(float __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
bool
isinf(double __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isinf(long double __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }
# 508 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isnan(_A1 __lcpp_x) noexcept
{
    return __builtin_isnan(__lcpp_x);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnan(_A1) noexcept
{ return false; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isnan(float __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
bool
isnan(double __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isnan(long double __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }
# 552 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept
{
    return __builtin_isnormal(__lcpp_x);
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{ return __lcpp_x != 0; }







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreater((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreaterequal((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isless((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessequal((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessgreater((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isunordered((__lcpp_x), (__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}
# 768 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long abs(long __x) noexcept {
  return ::labs(__x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long abs(long long __x) noexcept {
  return ::llabs(__x);
}





inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float abs(float __lcpp_x) noexcept {
  return ::fabsf(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) double abs(double __lcpp_x) noexcept {
  return ::fabs(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double
abs(long double __lcpp_x) noexcept {
  return ::fabsl(__lcpp_x);
}
# 804 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/math.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ldiv_t div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) lldiv_t div(long long __x,
                                             long long __y) noexcept {
  return ::lldiv(__x, __y);
}






inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float acos(float __lcpp_x) noexcept {return ::acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float asin(float __lcpp_x) noexcept {return ::asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atan(float __lcpp_x) noexcept {return ::atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return ::atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float ceil(float __lcpp_x) noexcept {return ::ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cos(float __lcpp_x) noexcept {return ::cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cosh(float __lcpp_x) noexcept {return ::coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float exp(float __lcpp_x) noexcept {return ::expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float floor(float __lcpp_x) noexcept {return ::floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return ::fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return ::frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log(float __lcpp_x) noexcept {return ::logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log10(float __lcpp_x) noexcept {return ::log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return ::modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}





inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return ::powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sin(float __lcpp_x) noexcept {return ::sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sinh(float __lcpp_x) noexcept {return ::sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sqrt(float __lcpp_x) noexcept {return ::sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tan(float __lcpp_x) noexcept {return ::tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tanh(float __lcpp_x) noexcept {return ::tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float acosh(float __lcpp_x) noexcept {return ::acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float asinh(float __lcpp_x) noexcept {return ::asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atanh(float __lcpp_x) noexcept {return ::atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cbrt(float __lcpp_x) noexcept {return ::cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float copysign(float __lcpp_x,
                                                float __lcpp_y) noexcept {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float erf(float __lcpp_x) noexcept {return ::erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float erfc(float __lcpp_x) noexcept {return ::erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float exp2(float __lcpp_x) noexcept {return ::exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float expm1(float __lcpp_x) noexcept {return ::expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return ::fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value &&
                     std::_IsSame<_A3, __result_type>::value)), "");
    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return ::fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return ::hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) int ilogb(float __lcpp_x) noexcept {return ::ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float lgamma(float __lcpp_x) noexcept {return ::lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llrint(float __lcpp_x) noexcept {return ::llrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llrint(long double __lcpp_x) noexcept {return ::llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {return ::llrint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llround(float __lcpp_x) noexcept {return ::llroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llround(long double __lcpp_x) noexcept {return ::llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {return ::llround((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log1p(float __lcpp_x) noexcept {return ::log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log2(float __lcpp_x) noexcept {return ::log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float logb(float __lcpp_x) noexcept {return ::logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lrint(float __lcpp_x) noexcept {return ::lrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lrint(long double __lcpp_x) noexcept {return ::lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {return ::lrint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lround(float __lcpp_x) noexcept {return ::lroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lround(long double __lcpp_x) noexcept {return ::lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {return ::lround((double)__lcpp_x);}





inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nearbyint(float __lcpp_x) noexcept {return ::nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return ::remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float rint(float __lcpp_x) noexcept {return ::rintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double rint(long double __lcpp_x) noexcept {return ::rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {return ::rint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float round(float __lcpp_x) noexcept {return ::roundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double round(long double __lcpp_x) noexcept {return ::roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {return ::round((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tgamma(float __lcpp_x) noexcept {return ::tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float trunc(float __lcpp_x) noexcept {return ::truncf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double trunc(long double __lcpp_x) noexcept {return ::truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {return ::trunc((double)__lcpp_x);}

}
# 101 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdlib.h" 2 3
# 86 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdlib" 2 3
# 89 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdlib" 3








namespace std { inline namespace __ndk1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;

using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;

using ::at_quick_exit;
using ::quick_exit;





} }
# 82 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/exception" 2 3
# 91 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/exception" 3


namespace std
{


class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception() noexcept {}
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};





typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void unexpected();


typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;

__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) int uncaught_exceptions() noexcept;

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);



class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr
make_exception_ptr(_Ep __e) noexcept
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }




}
# 234 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/exception" 3
class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;


    virtual ~nested_exception() noexcept;


    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};


template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void
    __do_throw(_Tp&& __t)
    {
        throw __nested<_Up>(std::__ndk1::forward<_Tp>(__t));
    }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void

    __do_throw(_Tp&& __t)



    {
        throw std::__ndk1::forward<_Tp>(__t);
    }
};


template <class _Tp>
[[noreturn]]
void
throw_with_nested(_Tp&& __t)
{

    typedef typename decay<_Tp>::type _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(std::__ndk1::forward<_Tp>(__t));




}

template <class _From, class _To>
struct __can_dynamic_cast : public integral_constant<bool,(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__ndk1::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

}
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdint" 1 3
# 148 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstdint" 3


namespace std { inline namespace __ndk1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 63 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 2 3
# 69 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 3






namespace std
{
# 159 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return reinterpret_cast<size_t>(__v);
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs, __rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs, __rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

   private:


    typedef std::integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static bool __is_type_name_unique(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return !((__lhs & __rhs) & __non_unique_rtti_bit::value);
    }
  };

  typedef





    __unique_impl



     __impl;
};

class __attribute__ ((__visibility__("default"))) type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);

 protected:
    typedef __type_info_implementations::__impl __impl;

    __impl::__type_name_t __type_name;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:

    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const type_info& __arg) const noexcept
    {
      return __impl::__eq(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};


class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  virtual ~bad_cast() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char* what() const noexcept;
};

}



namespace std { inline namespace __ndk1 {
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_bad_cast()
{

    throw bad_cast();



}
} }
# 654 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 1 3
# 104 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
# 125 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__ ((__visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;



[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc();




enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };
# 176 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
}
# 186 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz) noexcept;



                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator delete[](void*, void*) noexcept {}



namespace std { inline namespace __ndk1 {

constexpr inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 8U;



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void *__libcpp_allocate(size_t __size, size_t __align) {
# 248 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
  ((void)__align);




  return __builtin_operator_new(__size);

}

struct _DeallocateCaller {
  static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void __do_deallocate_handle_size_align(void *__ptr, size_t __size, size_t __align) {

    ((void)__align);
    return __do_deallocate_handle_size(__ptr, __size);
# 271 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
  }

  static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void __do_deallocate_handle_align(void *__ptr, size_t __align) {

    ((void)__align);
    return __do_call(__ptr);
# 286 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
  }

 private:
  static inline void __do_deallocate_handle_size(void *__ptr, size_t __size) {

    ((void)__size);
    return __do_call(__ptr);



  }
# 309 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
private:
  template <class _A1, class _A2>
  static inline void __do_call(void *__ptr, _A1 __a1, _A2 __a2) {




    return __builtin_operator_delete(__ptr, __a1, __a2);

  }

  template <class _A1>
  static inline void __do_call(void *__ptr, _A1 __a1) {




    return __builtin_operator_delete(__ptr, __a1);

  }

  static inline void __do_call(void *__ptr) {



    return __builtin_operator_delete(__ptr);

  }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {
  _DeallocateCaller::__do_deallocate_handle_size_align(__ptr, __size, __align);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {
  _DeallocateCaller::__do_deallocate_handle_align(__ptr, __align);
}

template <class _Tp>
                              inline
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void" );

    return __builtin_launder(__p);



}
# 370 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/new" 3
} }
# 657 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 1 3
# 199 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 1 3
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 3



namespace std { inline namespace __ndk1 {

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
    typedef __attribute__((nodebug)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
    typedef __attribute__((nodebug)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
    typedef __attribute__((nodebug)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 140 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;





template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;




template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;






template <class ..._Tp> struct __tuple_types {};
# 280 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 3
template <size_t _Ip, class ..._Types>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __attribute__((nodebug)) __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply __attribute__((nodebug)) = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t __attribute__((nodebug)) = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
# 343 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals __attribute__((nodebug)) = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((nodebug)) __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((nodebug)) __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t __attribute__((nodebug)) = typename tuple_element <_Ip, _Tp...>::type;


template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size __attribute__((nodebug)) = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {
    template <class ...>
    static constexpr bool __enable_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};
# 548 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__tuple" 3
} }
# 200 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/initializer_list" 1 3
# 50 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/initializer_list" 3


namespace std
{



template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 202 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstring" 1 3
# 60 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstring" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/string.h" 1 3
# 58 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/string.h" 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/strcasecmp.h" 1 3 4
# 40 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/strcasecmp.h" 3 4
extern "C" {
# 49 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/strcasecmp.h" 3 4
int strcasecmp(const char* __s1, const char* __s2) __attribute__((__pure__));
# 68 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/strcasecmp.h" 3 4
int strncasecmp(const char* __s1, const char* __s2, size_t __n) __attribute__((__pure__));
# 79 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/strcasecmp.h" 3 4
}
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 2 3 4

extern "C" {



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/strings.h" 1 3 4
# 52 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/strings.h" 3 4
extern "C" {



static __inline__ __attribute__((__always_inline__)) void __bionic_bcopy(const void* b1, void* b2, size_t len) {
  __builtin_memmove(b2, b1, len);
}



static __inline__ __attribute__((__always_inline__)) void __bionic_bzero(void* b, size_t len) {
  __builtin_memset(b, 0, len);
}







int ffs(int __i) __attribute__((annotate("introduced_in_x86=" "18")));




# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/strings.h" 1 3 4
# 31 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/strings.h" 3 4
static __inline__ __attribute__((__always_inline__))
void __bionic_bcopy(const void *src, void* const dst __attribute__((pass_object_size(0))), size_t len)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (0))) != ((size_t) -1) && (__builtin_object_size(((dst)), (0))) < (len)), "'bcopy' called with size bigger than buffer", "error"))) {
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/strings.h" 3 4
    __builtin_memmove(dst, src, len);
}

static __inline__ __attribute__((__always_inline__))
void __bionic_bzero(void* const b __attribute__((pass_object_size(0))), size_t len)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((b)), (0))) != ((size_t) -1) && (__builtin_object_size(((b)), (0))) < (len)), "'bzero' called with size bigger than buffer", "error"))) {
# 58 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/strings.h" 3 4
    __builtin_memset(b, 0, len);
}
# 77 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/strings.h" 2 3 4


}


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_strings_inlines.h" 1 3 4
# 82 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/strings.h" 2 3 4
# 42 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 2 3 4


void* memccpy(void* __dst, const void* __src, int __stop_char, size_t __n);
void* memchr(const void* __s, int __ch, size_t __n) __attribute__((__pure__));

extern "C++" void* memrchr(void* __s, int __ch, size_t __n) __asm__("memrchr") __attribute__((__pure__));
extern "C++" const void* memrchr(const void* __s, int __ch, size_t __n) __asm__("memrchr") __attribute__((__pure__));



int memcmp(const void* __lhs, const void* __rhs, size_t __n) __attribute__((__pure__));
void* memcpy(void*, const void*, size_t);







void* memmove(void* __dst, const void* __src, size_t __n);
void* memset(void* __dst, int __ch, size_t __n);
void* memmem(const void* __haystack, size_t __haystack_size, const void* __needle, size_t __needle_size) __attribute__((__pure__));

char* strchr(const char* __s, int __ch) __attribute__((__pure__));
# 88 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 3 4
char* strrchr(const char* __s, int __ch) __attribute__((__pure__));






size_t strlen(const char* __s) __attribute__((__pure__));






int strcmp(const char* __lhs, const char* __rhs) __attribute__((__pure__));





char* strcpy(char* __dst, const char* __src);
char* strcat(char* __dst, const char* __src);
char* strdup(const char* __s);

char* strstr(const char* __haystack, const char* __needle) __attribute__((__pure__));

extern "C++" char* strcasestr(char*, const char*) __asm__("strcasestr") __attribute__((__pure__));
extern "C++" const char* strcasestr(const char*, const char*) __asm__("strcasestr") __attribute__((__pure__));



char* strtok(char* __s, const char* __delimiter);
char* strtok_r(char* __s, const char* __delimiter, char** __pos_ptr);

char* strerror(int __errno_value);
# 131 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 3 4
int strerror_r(int __errno_value, char* __buf, size_t __n);


size_t strnlen(const char* __s, size_t __n) __attribute__((__pure__));
char* strncat(char* __dst, const char* __src, size_t __n);
char* strndup(const char* __s, size_t __n);
int strncmp(const char* __lhs, const char* __rhs, size_t __n) __attribute__((__pure__));





char* strncpy(char* __dst, const char* __src, size_t __n);

size_t strlcat(char* __dst, const char* __src, size_t __n);
size_t strlcpy(char* __dst, const char* __src, size_t __n);

size_t strcspn(const char* __s, const char* __reject) __attribute__((__pure__));
char* strpbrk(const char* __s, const char* __accept) __attribute__((__pure__));
char* strsep(char** __s_ptr, const char* __delimiter);
size_t strspn(const char* __s, const char* __accept);

char* strsignal(int __signal);

int strcoll(const char* __lhs, const char* __rhs) __attribute__((__pure__));
size_t strxfrm(char* __dst, const char* __src, size_t __n);
# 187 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 1 3 4
# 53 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
extern void* __memrchr_real(const void*, int, size_t) __asm__("memrchr");
# 94 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
static __inline__ __attribute__((__always_inline__))
char* stpcpy(char* const dst __attribute__((pass_object_size(1))), const char* src)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (1))) != ((size_t) -1) && (__builtin_object_size(((dst)), (1))) <= (__builtin_strlen(src))), "'stpcpy' called with string bigger than buffer", "error"))) {







    return __builtin_stpcpy(dst, src);
}

static __inline__ __attribute__((__always_inline__))
char* strcpy(char* const dst __attribute__((pass_object_size(1))), const char* src)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (1))) != ((size_t) -1) && (__builtin_object_size(((dst)), (1))) <= (__builtin_strlen(src))), "'strcpy' called with string bigger than buffer", "error"))) {







    return __builtin_strcpy(dst, src);
}

static __inline__ __attribute__((__always_inline__))
char* strcat(char* const dst __attribute__((pass_object_size(1))), const char* src)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (1))) != ((size_t) -1) && (__builtin_object_size(((dst)), (1))) <= (__builtin_strlen(src))), "'strcat' called with string bigger than buffer", "error"))) {




    return __builtin_strcat(dst, src);

}
# 143 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
static __inline__ __attribute__((__always_inline__))
void* memset(void* const s __attribute__((pass_object_size(0))), int c, size_t n) __attribute__((overloadable))

        __attribute__((diagnose_if(c && !n, "'memset' will set 0 bytes; maybe the arguments got flipped?", "warning"))) {






    return __builtin_memset(s, c, n);
}
# 212 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
static __inline__ __attribute__((__always_inline__))
size_t strlcpy(char* const dst __attribute__((pass_object_size(1))), const char* src, size_t size)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (1))) != ((size_t) -1) && (__builtin_object_size(((dst)), (1))) < (size)), "'strlcpy' called with size bigger than buffer", "error"))) {
# 224 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
    return (&strlcpy)(dst, src, size);
}

static __inline__ __attribute__((__always_inline__))
size_t strlcat(char* const dst __attribute__((pass_object_size(1))), const char* src, size_t size)
        __attribute__((overloadable))
        __attribute__((diagnose_if(((__builtin_object_size(((dst)), (1))) != ((size_t) -1) && (__builtin_object_size(((dst)), (1))) < (size)), "'strlcat' called with size bigger than buffer", "error"))) {
# 239 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/fortify/string.h" 3 4
    return (&strlcat)(dst, src, size);
}

static __inline__ __attribute__((__always_inline__))
size_t strlen(const char* const s __attribute__((pass_object_size(0)))) __attribute__((overloadable)) {
    size_t bos = __builtin_object_size(((s)), (0));






    return __builtin_strlen(s);
}

static __inline__ __attribute__((__always_inline__))
char* strchr(const char* const s __attribute__((pass_object_size(1))), int c) __attribute__((overloadable)) {







    return __builtin_strchr(s, c);
}

static __inline__ __attribute__((__always_inline__))
char* strrchr(const char* const s __attribute__((pass_object_size(1))), int c) __attribute__((overloadable)) {







    return __builtin_strrchr(s, c);
}
# 188 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 2 3 4
# 197 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/string.h" 3 4
extern "C++" {
inline __attribute__((__always_inline__))
void* __bionic_memchr(const void* const s __attribute__((pass_object_size(1))), int c, size_t n) {
    return memchr(s, c, n);
}

inline __attribute__((__always_inline__))
const void* memchr(const void* const s __attribute__((pass_object_size(1))), int c, size_t n)
        __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_memchr(s, c, n);
}

inline __attribute__((__always_inline__))
void* memchr(void* const s __attribute__((pass_object_size(1))), int c, size_t n) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_memchr(s, c, n);
}

inline __attribute__((__always_inline__))
char* __bionic_strchr(const char* const s __attribute__((pass_object_size(1))), int c) {
    return strchr(s, c);
}

inline __attribute__((__always_inline__))
const char* strchr(const char* const s __attribute__((pass_object_size(1))), int c)
        __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strchr(s, c);
}

inline __attribute__((__always_inline__))
char* strchr(char* const s __attribute__((pass_object_size(1))), int c)
        __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strchr(s, c);
}

inline __attribute__((__always_inline__))
char* __bionic_strrchr(const char* const s __attribute__((pass_object_size(1))), int c) {
    return strrchr(s, c);
}

inline __attribute__((__always_inline__))
const char* strrchr(const char* const s __attribute__((pass_object_size(1))), int c) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strrchr(s, c);
}

inline __attribute__((__always_inline__))
char* strrchr(char* const s __attribute__((pass_object_size(1))), int c) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strrchr(s, c);
}


inline __attribute__((__always_inline__))
char* __bionic_strstr(const char* h, const char* n) { return strstr(h, n); }

inline __attribute__((__always_inline__))
const char* strstr(const char* h, const char* n) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strstr(h, n);
}

inline __attribute__((__always_inline__))
char* strstr(char* h, const char* n) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strstr(h, n);
}

inline __attribute__((__always_inline__))
char* __bionic_strpbrk(const char* h, const char* n) { return strpbrk(h, n); }

inline __attribute__((__always_inline__))
char* strpbrk(char* h, const char* n) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strpbrk(h, n);
}

inline __attribute__((__always_inline__))
const char* strpbrk(const char* h, const char* n) __attribute__((enable_if(true, "preferred overload"))) __attribute__((enable_if(true, ""))) {
    return __bionic_strpbrk(h, n);
}
}



}
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/string.h" 2 3
# 71 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/string.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstring" 2 3
# 64 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cstring" 3


namespace std { inline namespace __ndk1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }
# 204 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 2 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 1 3
# 14 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iosfwd" 1 3
# 95 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iosfwd" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/wchar.h" 1 3
# 112 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/wchar.h" 3






# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/wchar.h" 1 3
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/wchar.h" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdio.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/time.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/time.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/time.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/time.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/time.h" 1 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/time.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/time_types.h" 1 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/time_types.h" 3 4
struct __kernel_timespec {
  __kernel_time64_t tv_sec;
  long long tv_nsec;
};
struct __kernel_itimerspec {
  struct __kernel_timespec it_interval;
  struct __kernel_timespec it_value;
};

struct __kernel_old_timeval {
  __kernel_long_t tv_sec;
  __kernel_long_t tv_usec;
};

struct __kernel_sock_timeval {
  __s64 tv_sec;
  __s64 tv_usec;
};
# 23 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/time.h" 2 3 4


struct timespec {
  __kernel_time_t tv_sec;
  long tv_nsec;
};

struct timeval {
  __kernel_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};



struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};
struct itimerval {
  struct timeval it_interval;
  struct timeval it_value;
};
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/time.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 1 3 4
# 40 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 1 3 4
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/sigcontext.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/sigcontext.h" 3 4
struct sigcontext {
  unsigned long trap_no;
  unsigned long error_code;
  unsigned long oldmask;
  unsigned long arm_r0;
  unsigned long arm_r1;
  unsigned long arm_r2;
  unsigned long arm_r3;
  unsigned long arm_r4;
  unsigned long arm_r5;
  unsigned long arm_r6;
  unsigned long arm_r7;
  unsigned long arm_r8;
  unsigned long arm_r9;
  unsigned long arm_r10;
  unsigned long arm_fp;
  unsigned long arm_ip;
  unsigned long arm_sp;
  unsigned long arm_lr;
  unsigned long arm_pc;
  unsigned long arm_cpsr;
  unsigned long fault_address;
};
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/signal_types.h" 1 3 4
# 42 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/signal_types.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/signal.h" 1 3 4
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/signal.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/signal.h" 1 3 4
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/signal.h" 3 4
struct siginfo;

typedef unsigned long sigset_t;
# 75 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/signal.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/signal-defs.h" 1 3 4
# 32 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/signal-defs.h" 3 4
typedef void __signalfn_t(int);
typedef __signalfn_t * __sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t * __sigrestore_t;
# 76 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/signal.h" 2 3 4
struct __kernel_sigaction {
  union {
    __sighandler_t _sa_handler;
    void(* _sa_sigaction) (int, struct siginfo *, void *);
  } _u;
  sigset_t sa_mask;
  unsigned long sa_flags;
  void(* sa_restorer) (void);
};


typedef struct sigaltstack {
  void * ss_sp;
  int ss_flags;
  size_t ss_size;
} stack_t;
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/signal.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/siginfo.h" 1 3 4
# 19 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/siginfo.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/siginfo.h" 1 3 4
# 23 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/siginfo.h" 3 4
typedef union sigval {
  int sival_int;
  void * sival_ptr;
} sigval_t;
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/siginfo.h" 3 4
union __sifields {
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
  } _kill;
  struct {
    __kernel_timer_t _tid;
    int _overrun;
    sigval_t _sigval;
    int _sys_private;
  } _timer;
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
    sigval_t _sigval;
  } _rt;
  struct {
    __kernel_pid_t _pid;
    __kernel_uid32_t _uid;
    int _status;
    __kernel_clock_t _utime;
    __kernel_clock_t _stime;
  } _sigchld;
  struct {
    void * _addr;
# 71 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/siginfo.h" 3 4
    union {
      short _addr_lsb;
      struct {
        char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
        void * _lower;
        void * _upper;
      } _addr_bnd;
      struct {
        char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
        __u32 _pkey;
      } _addr_pkey;
    };
  } _sigfault;
  struct {
    long _band;
    int _fd;
  } _sigpoll;
  struct {
    void * _call_addr;
    int _syscall;
    unsigned int _arch;
  } _sigsys;
};







typedef struct siginfo {
  union {
    struct { int si_signo; int si_errno; int si_code; union __sifields _sifields; };
    int _si_pad[128 / sizeof(int)];
  };
} siginfo_t;
# 222 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/asm-generic/siginfo.h" 3 4
typedef struct sigevent {
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union {
    int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
    int _tid;
    struct {
      void(* _function) (sigval_t);
      void * _attribute;
    } _sigev_thread;
  } _sigev_un;
} sigevent_t;
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/arm-linux-androideabi/asm/siginfo.h" 2 3 4
# 23 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/linux/signal.h" 2 3 4
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/signal_types.h" 2 3 4
# 54 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/signal_types.h" 3 4
typedef int sig_atomic_t;

typedef __sighandler_t sig_t;
typedef __sighandler_t sighandler_t;







typedef struct { unsigned long __bits[64/32]; } sigset64_t;
# 104 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/signal_types.h" 3 4
struct sigaction {
  union {
    sighandler_t sa_handler;
    void (*sa_sigaction)(int, struct siginfo*, void*);
  };
  sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};


struct sigaction64 {
  union {
    sighandler_t sa_handler;
    void (*sa_sigaction)(int, struct siginfo*, void*);
  };
  int sa_flags;
  void (*sa_restorer)(void);
  sigset64_t sa_mask;
};
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/timespec.h" 1 3 4
# 39 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/ucontext.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/ucontext.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 1 3 4
# 35 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/ucontext.h" 2 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/user.h" 1 3 4
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/user.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stddef.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/user.h" 2 3 4


extern "C" {
# 193 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/user.h" 3 4
struct user_fpregs {
  struct fp_reg {
    unsigned int sign1:1;
    unsigned int unused:15;
    unsigned int sign2:1;
    unsigned int exponent:14;
    unsigned int j:1;
    unsigned int mantissa1:31;
    unsigned int mantissa0:32;
  } fpregs[8];
  unsigned int fpsr:32;
  unsigned int fpcr:32;
  unsigned char ftype[8];
  unsigned int init_flag;
};
struct user_regs {
  unsigned long uregs[18];
};
struct user_vfp {
  unsigned long long fpregs[32];
  unsigned long fpscr;
};
struct user_vfp_exc {
  unsigned long fpexc;
  unsigned long fpinst;
  unsigned long fpinst2;
};
struct user {
  struct user_regs regs;
  int u_fpvalid;
  unsigned long int u_tsize;
  unsigned long int u_dsize;
  unsigned long int u_ssize;
  unsigned long start_code;
  unsigned long start_stack;
  long int signal;
  int reserved;
  struct user_regs* u_ar0;
  unsigned long magic;
  char u_comm[32];
  int u_debugreg[8];
  struct user_fpregs u_fp;
  struct user_fpregs* u_fp0;
};
# 258 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/user.h" 3 4
}
# 36 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/ucontext.h" 2 3 4

extern "C" {



enum {
  REG_R0 = 0,

  REG_R1,

  REG_R2,

  REG_R3,

  REG_R4,

  REG_R5,

  REG_R6,

  REG_R7,

  REG_R8,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

};



typedef int greg_t;
typedef greg_t gregset_t[18];
typedef struct user_fpregs fpregset_t;


typedef struct sigcontext mcontext_t;

typedef struct ucontext {
  unsigned long uc_flags;
  struct ucontext* uc_link;
  stack_t uc_stack;
  mcontext_t uc_mcontext;
  union {
    struct {
      sigset_t uc_sigmask;

      uint32_t __padding_rt_sigset;
    };
    sigset64_t uc_sigmask64;
  };

  char __padding[120];
  unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
} ucontext_t;
# 390 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/ucontext.h" 3 4
}
# 42 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 2 3 4


extern "C" {
# 61 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
extern const char* const sys_siglist[(64 + 1)];
extern const char* const sys_signame[(64 + 1)];



int sigaction(int __signal, const struct sigaction* __new_action, struct sigaction* __old_action);






int siginterrupt(int __signal, int __flag);
# 111 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
int sigpending(sigset_t* __set);





int sigprocmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);





int sigsuspend(const sigset_t* __mask);





int sigwait(const sigset_t* __set, int* __signal);
# 153 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
int raise(int __signal);
int kill(pid_t __pid, int __signal);
int killpg(int __pgrp, int __signal);
int tgkill(int __tgid, int __tid, int __signal);

int sigaltstack(const stack_t* __new_signal_stack, stack_t* __old_signal_stack);
# 167 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
int pthread_kill(pthread_t __pthread, int __signal);
# 176 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
int pthread_sigmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);
# 205 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 3 4
}


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_signal_inlines.h" 1 3 4
# 37 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_signal_inlines.h" 3 4
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 1 3 4
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/android/legacy_signal_inlines.h" 2 3 4


extern "C" {

sighandler_t bsd_signal(int __signal, sighandler_t __handler) __attribute__((annotate("obsoleted_in=" "21")));


int __libc_current_sigrtmax() __attribute__((__weak__)) __attribute__((annotate("versioner_no_guard")));
int __libc_current_sigrtmin() __attribute__((__weak__)) __attribute__((annotate("versioner_no_guard")));

static inline int __ndk_legacy___libc_current_sigrtmax() {
  if (__libc_current_sigrtmax) return __libc_current_sigrtmax();
  return 64;
}

static inline int __ndk_legacy___libc_current_sigrtmin() {
  if (__libc_current_sigrtmin) return __libc_current_sigrtmin();
  return 32 + 7;
}






static inline int sigismember(const sigset_t *set, int signum) {

  int bit = signum - 1;
  const unsigned long *local_set = (const unsigned long *)set;
  if (set == __null || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
    (*__errno()) = 22;
    return -1;
  }
  return (int)((local_set[bit / 32] >> (bit % 32)) & 1);
}

static inline int sigaddset(sigset_t *set, int signum) {

  int bit = signum - 1;
  unsigned long *local_set = (unsigned long *)set;
  if (set == __null || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
    (*__errno()) = 22;
    return -1;
  }
  local_set[bit / 32] |= 1UL << (bit % 32);
  return 0;
}

static inline int sigdelset(sigset_t *set, int signum) {

  int bit = signum - 1;
  unsigned long *local_set = (unsigned long *)set;
  if (set == __null || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
    (*__errno()) = 22;
    return -1;
  }
  local_set[bit / 32] &= ~(1UL << (bit % 32));
  return 0;
}

static inline int sigemptyset(sigset_t *set) {
  if (set == __null) {
    (*__errno()) = 22;
    return -1;
  }
  memset(set, 0, sizeof(sigset_t));
  return 0;
}

static inline int sigfillset(sigset_t *set) {
  if (set == __null) {
    (*__errno()) = 22;
    return -1;
  }
  memset(set, ~0, sizeof(sigset_t));
  return 0;
}

static inline sighandler_t signal(int s, sighandler_t f) {
  return bsd_signal(s, f);
}

}
# 208 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/signal.h" 2 3 4
# 41 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 2 3 4

extern "C" {

typedef unsigned long fd_mask;
# 57 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 3 4
typedef struct {
  fd_mask fds_bits[1024/(8 * sizeof(fd_mask))];
} fd_set;
# 113 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 3 4
int select(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, struct timeval* __timeout);
# 122 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 3 4
int pselect(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, const struct timespec* __timeout, const sigset_t* __mask);
# 139 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/select.h" 3 4
}
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/time.h" 2 3 4

extern "C" {

int gettimeofday(struct timeval* __tv, struct timezone* __tz);
int settimeofday(const struct timeval* __tv, const struct timezone* __tz);

int getitimer(int __which, struct itimerval* __current_value);
int setitimer(int __which, const struct itimerval* __new_value, struct itimerval* __old_value);

int utimes(const char* __path, const struct timeval __times[2]);
# 106 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/sys/time.h" 3 4
}
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/time.h" 2 3 4


extern "C" {



extern char* tzname[];
extern int daylight;
extern long int timezone;

struct sigevent;

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long int tm_gmtoff;
  const char* tm_zone;
};



time_t time(time_t* __t);
int nanosleep(const struct timespec* __request, struct timespec* __remainder);

char* asctime(const struct tm* __tm);
char* asctime_r(const struct tm* __tm, char* __buf);

double difftime(time_t __lhs, time_t __rhs);
time_t mktime(struct tm* __tm);

struct tm* localtime(const time_t* __t);
struct tm* localtime_r(const time_t* __t, struct tm* __tm);

struct tm* gmtime(const time_t* __t);
struct tm* gmtime_r(const time_t* __t, struct tm* __tm);

char* strptime(const char* __s, const char* __fmt, struct tm* __tm) __attribute__((__format__(strftime, 2, 0)));






size_t strftime(char* __buf, size_t __n, const char* __fmt, const struct tm* __tm) __attribute__((__format__(strftime, 3, 0)));






char* ctime(const time_t* __t);
char* ctime_r(const time_t* __t, char* __buf);

void tzset(void);

clock_t clock(void);







int clock_getres(clockid_t __clock, struct timespec* __resolution);
int clock_gettime(clockid_t __clock, struct timespec* __ts);
int clock_nanosleep(clockid_t __clock, int __flags, const struct timespec* __request, struct timespec* __remainder);
int clock_settime(clockid_t __clock, const struct timespec* __ts);

int timer_create(clockid_t __clock, struct sigevent* __event, timer_t* __timer_ptr);
int timer_delete(timer_t __timer);
int timer_settime(timer_t __timer, int __flags, const struct itimerspec* __new_value, struct itimerspec* __old_value);
int timer_gettime(timer_t __timer, struct itimerspec* __ts);
int timer_getoverrun(timer_t __timer);


time_t timelocal(struct tm* __tm);
time_t timegm(struct tm* __tm);
# 126 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/time.h" 3 4
}
# 38 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 2 3 4


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/mbstate_t.h" 1 3 4
# 42 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/mbstate_t.h" 3 4
typedef struct {
  unsigned char __seq[4];



} mbstate_t;
# 41 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 2 3 4

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wctype.h" 1 3 4
# 34 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/bits/wctype.h" 3 4
extern "C" {

typedef unsigned int wint_t;



int iswalnum(wint_t __wc);
int iswalpha(wint_t __wc);





int iswcntrl(wint_t __wc);
int iswdigit(wint_t __wc);
int iswgraph(wint_t __wc);
int iswlower(wint_t __wc);
int iswprint(wint_t __wc);
int iswpunct(wint_t __wc);
int iswspace(wint_t __wc);
int iswupper(wint_t __wc);
int iswxdigit(wint_t __wc);

wint_t towlower(wint_t __wc);
wint_t towupper(wint_t __wc);

typedef long wctype_t;
wctype_t wctype(const char* __name);
int iswctype(wint_t __wc, wctype_t __type);

typedef const void* wctrans_t;
wint_t towctrans(wint_t __wc, wctrans_t __transform) __attribute__((annotate("introduced_in=" "26"))) __attribute__((annotate("versioner_no_guard")));
wctrans_t wctrans(const char* __name) __attribute__((annotate("introduced_in=" "26"))) __attribute__((annotate("versioner_no_guard")));

}
# 43 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 2 3 4

extern "C" {

wint_t btowc(int __ch);
int fwprintf(FILE* __fp, const wchar_t* __fmt, ...);
int fwscanf(FILE* __fp, const wchar_t* __fmt, ...);
wint_t fgetwc(FILE* __fp);
wchar_t* fgetws(wchar_t* __buf, int __size, FILE* __fp);
wint_t fputwc(wchar_t __wc, FILE* __fp);
int fputws(const wchar_t* __s, FILE* __fp);
int fwide(FILE* __fp, int __mode);
wint_t getwc(FILE* __fp);
wint_t getwchar(void);
int mbsinit(const mbstate_t* __ps);
size_t mbrlen(const char* __s, size_t __n, mbstate_t* __ps);
size_t mbrtowc(wchar_t* __buf, const char* __s, size_t __n, mbstate_t* __ps);
size_t mbsrtowcs(wchar_t* __dst, const char** __src, size_t __dst_n, mbstate_t* __ps);





wint_t putwc(wchar_t __wc, FILE* __fp);
wint_t putwchar(wchar_t __wc);
int swprintf(wchar_t* __buf, size_t __n, const wchar_t* __fmt, ...);
int swscanf(const wchar_t* __s, const wchar_t* __fmt, ...);
wint_t ungetwc(wint_t __wc, FILE* __fp);
int vfwprintf(FILE* __fp, const wchar_t* __fmt, va_list __args);





int vswprintf(wchar_t* __buf, size_t __n, const wchar_t* __fmt, va_list __args);





int vwprintf(const wchar_t* __fmt, va_list __args);





wchar_t* wcpcpy(wchar_t* __dst, const wchar_t* __src);
wchar_t* wcpncpy(wchar_t* __dst, const wchar_t* __src, size_t __n);
size_t wcrtomb(char* __buf, wchar_t __wc, mbstate_t* __ps);
int wcscasecmp(const wchar_t* __lhs, const wchar_t* __rhs);





wchar_t* wcscat(wchar_t* __dst, const wchar_t* __src);
wchar_t* wcschr(const wchar_t* __s, wchar_t __wc);
int wcscmp(const wchar_t* __lhs, const wchar_t* __rhs);
int wcscoll(const wchar_t* __lhs, const wchar_t* __rhs);
wchar_t* wcscpy(wchar_t* __dst, const wchar_t* __src);
size_t wcscspn(const wchar_t* __s, const wchar_t* __accept);
size_t wcsftime(wchar_t* __buf, size_t __n, const wchar_t* __fmt, const struct tm* __tm);





size_t wcslen(const wchar_t* __s);
int wcsncasecmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __n);





wchar_t* wcsncat(wchar_t* __dst, const wchar_t* __src, size_t __n);
int wcsncmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __n);
wchar_t* wcsncpy(wchar_t* __dst, const wchar_t* __src, size_t __n);





wchar_t* wcspbrk(const wchar_t* __s, const wchar_t* __accept);
wchar_t* wcsrchr(const wchar_t* __s, wchar_t __wc);
size_t wcsrtombs(char* __dst, const wchar_t** __src, size_t __dst_n, mbstate_t* __ps);
size_t wcsspn(const wchar_t* __s, const wchar_t* __accept);
wchar_t* wcsstr(const wchar_t* __haystack, const wchar_t* __needle);
double wcstod(const wchar_t* __s, wchar_t** __end_ptr);
# 145 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 3 4
wchar_t* wcstok(wchar_t* __s, const wchar_t* __delimiter, wchar_t** __ptr);
long wcstol(const wchar_t* __s, wchar_t** __end_ptr, int __base);
# 157 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 3 4
long double wcstold(const wchar_t* __s, wchar_t** __end_ptr) __asm__("wcstod") __attribute__((annotate("introduced_in=" "3")));
unsigned long wcstoul(const wchar_t* __s, wchar_t** __end_ptr, int __base);
# 169 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 3 4
int wcswidth(const wchar_t* __s, size_t __n);
size_t wcsxfrm(wchar_t* __dst, const wchar_t* __src, size_t __n);
int wctob(wint_t __wc);
int wcwidth(wchar_t __wc);
wchar_t* wmemchr(const wchar_t* __src, wchar_t __wc, size_t __n);
int wmemcmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __n);
wchar_t* wmemcpy(wchar_t* __dst, const wchar_t* __src, size_t __n);







wchar_t* wmemmove(wchar_t* __dst, const wchar_t* __src, size_t __n);
wchar_t* wmemset(wchar_t* __dst, wchar_t __wc, size_t __n);
int wprintf(const wchar_t* __fmt, ...);
int wscanf(const wchar_t* __fmt, ...);
# 200 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/wchar.h" 3 4
size_t wcslcat(wchar_t* __dst, const wchar_t* __src, size_t __n);
size_t wcslcpy(wchar_t* __dst, const wchar_t* __src, size_t __n);






wchar_t* wcsdup(const wchar_t* __s);
size_t wcsnlen(const wchar_t* __s, size_t __n);

}
# 33 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/local/include/wchar.h" 2 3

extern "C" {


int vfwscanf(FILE*, const wchar_t*, va_list);
int vswscanf(const wchar_t*, const wchar_t*, va_list);
int vwscanf(const wchar_t*, va_list);
size_t mbsnrtowcs(wchar_t*, const char**, size_t, size_t, mbstate_t*);
size_t wcsnrtombs(char*, const wchar_t**, size_t, size_t, mbstate_t*);
float wcstof(const wchar_t*, wchar_t**);
long long wcstoll(const wchar_t*, wchar_t**, int);
unsigned long long wcstoull(const wchar_t*, wchar_t**, int);


}
# 119 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/wchar.h" 2 3
# 134 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
# 96 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iosfwd" 2 3
# 99 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iosfwd" 3


namespace std { inline namespace __ndk1 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<> struct char_traits<char>;



template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;

} }
# 15 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 2 3
# 18 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 3
# 52 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 3
namespace std { inline namespace __ndk1 {

struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  __attribute__ ((__visibility__("default"))) std::string what() const;

  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);



extern __attribute__((__visibility__("default"))) __libcpp_debug_function_type __libcpp_debug_function;


[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);



__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 276 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__debug" 3
} }
# 207 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 2 3
# 210 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3


namespace std { inline namespace __ndk1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}




template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}


template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
{
    std::__ndk1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) noexcept
{
    return std::__ndk1::move(__x);
}






struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };



                         constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 314 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 351 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
    template <bool _Val>
    using _EnableB __attribute__((nodebug)) = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <class _U1, class _U2>
      static constexpr bool __enable_default() {
          return is_default_constructible<_U1>::value
              && is_default_constructible<_U2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep __attribute__((nodebug)) = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC __attribute__((nodebug)) = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__ndk1::forward<_U1>(__u1)), second(std::__ndk1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__ndk1::forward<_U1>(__u1)), second(std::__ndk1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__ndk1::forward<_U1>(__p.first)), second(std::__ndk1::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__ndk1::forward<_U1>(__p.first)), second(std::__ndk1::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::__ndk1::get<0>(std::__ndk1::forward<_Tuple>(__p))),
          second(std::__ndk1::get<1>(std::__ndk1::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_Tuple&& __p)
        : first(std::__ndk1::get<0>(std::__ndk1::forward<_Tuple>(__p))),
          second(std::__ndk1::get<1>(std::__ndk1::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))

        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__ndk1::forward<first_type>(__p.first);
        second = std::__ndk1::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(_Tuple&& __p) {
        first = std::__ndk1::get<0>(std::__ndk1::forward<_Tuple>(__p));
        second = std::__ndk1::get<1>(std::__ndk1::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__ndk1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair(piecewise_construct_t,
             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
             __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};






template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}

template <class _Tp>
struct __unwrap_reference { typedef __attribute__((nodebug)) _Tp type; };

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef __attribute__((nodebug)) _Tp& type; };
# 653 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _Tp>
struct __unwrap_ref_decay



    : __unwrap_reference<typename decay<_Tp>::type>

{ };



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::__ndk1::forward<_T1>(__t1), std::__ndk1::forward<_T2>(__t2));
}
# 685 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _T1, class _T2>
  struct __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
    typedef __attribute__((nodebug)) _T1 type;
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
    typedef __attribute__((nodebug)) _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__ndk1::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__ndk1::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__ndk1::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__ndk1::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__ndk1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__ndk1::move(__p));
}



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::__ndk1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::__ndk1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::__ndk1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::__ndk1::move(__p));
}





template<class _Tp, _Tp... _Ip>
struct __attribute__ ((__type_visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence __attribute__((nodebug)) = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 906 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;




template<class _T1, class _T2 = _T1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__ndk1::move(__obj);
    __obj = std::__ndk1::forward<_T2>(__new_value);
    return __old_value;
}
# 963 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
        [[clang::fallthrough]];
    case 2:
        __h ^= __data[1] << 8;
        [[clang::fallthrough]];
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};


template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};
# 1474 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0.0L)
            return 0;
# 1547 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};



template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash : public __enum_hash<_Tp>
{
};
# 1592 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _Key, class _Hash>
using __check_hash_requirements __attribute__((nodebug)) = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = std::hash<_Key> >
using __has_enabled_hash __attribute__((nodebug)) = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;
# 1614 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/utility" 3
template <class _Type, class ...>
using __enable_hash_helper __attribute__((nodebug)) = _Type;




} }
# 658 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 1 3
# 421 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 1 3
# 22 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3


namespace std { inline namespace __ndk1 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__ndk1::forward<_T1>(__t) < std::__ndk1::forward<_T2>(__u)))
    -> decltype (std::__ndk1::forward<_T1>(__t) < std::__ndk1::forward<_T2>(__u))
        { return std::__ndk1::forward<_T1>(__t) < std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef __attribute__((nodebug)) typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef __attribute__((nodebug)) _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};





template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(__invoke(std::__ndk1::declval<_Tp>(), std::__ndk1::declval<_Args>()...)) type;
};
# 311 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3
template <class _Ret>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return __invoke(std::__ndk1::forward<_Args>(__args)...);
    }
# 340 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3
};

template <>
struct __invoke_void_return_wrapper<void>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        __invoke(std::__ndk1::forward<_Args>(__args)...);
    }
# 371 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference_wrapper(type& __f) noexcept
        : __f_(std::__ndk1::addressof(__f)) {}

    private: reference_wrapper(type&&); public:



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) operator type& () const noexcept {return *__f_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) type& get() const noexcept {return *__f_;}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return __invoke(get(), std::__ndk1::forward<_ArgTypes>(__args)...);
    }
# 509 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3
};


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};




struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };




                         constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 610 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__functional_base" 3
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef __attribute__((nodebug)) typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__ndk1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__ndk1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__ndk1::forward<_Args>(__args)..., __a);
}



} }
# 422 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 2 3
# 434 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3


namespace std { inline namespace __ndk1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type* = 0,
              typename std::__void_t<typename _Up::difference_type>::type* = 0,
              typename std::__void_t<typename _Up::value_type>::type* = 0,
              typename std::__void_t<typename _Up::reference>::type* = 0,
              typename std::__void_t<typename _Up::pointer>::type* = 0
              );
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};


template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};
# 557 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    ((void)0);

    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);


    std::__ndk1::advance(__x, __n);
    return __x;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_input_iterator<_InputIter>::value,
    _InputIter
>::type
prev(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);

    std::__ndk1::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
                _Iter __t;

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator() : __t(), current() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {return std::__ndk1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 803 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit back_insert_iterator(_Container& __x) : container(std::__ndk1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__ndk1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit front_insert_iterator(_Container& __x) : container(std::__ndk1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__ndk1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__ndk1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__ndk1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr istream_iterator() : __in_stream_(0), __value_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator(istream_type& __s) : __in_stream_(std::__ndk1::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp* operator->() const {return std::__ndk1::addressof((operator*()));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__ndk1::addressof(__s)), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__ndk1::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr istreambuf_iterator() noexcept : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool failed() const noexcept {return __sbuf_ == 0;}

    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;

    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const { return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 1239 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());







template <class _Iter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) move_backward(_B1, _B1, _B2);



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
# 1336 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter() noexcept

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) noexcept
            : __i(__u.base())
    {



    }
# 1390 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr pointer operator->() const noexcept
    {




        return (pointer)std::__ndk1::addressof(*__i);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;
    template <class _Tp, size_t> friend class __attribute__ ((__type_visibility__("default"))) span;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


    template <class _Iter1, class _Iter2>
    constexpr friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());







    template <class _Iter1>
    constexpr friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);


    template <class _Tp>
    constexpr friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
# 1542 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
{




    return __x.base() - __y.base();
}
# 1655 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool,(is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public integral_constant<bool,(__libcpp_is_trivial_iterator<_Iter>::value)> {};


template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::__ndk1::begin(__c))
{
    return std::__ndk1::begin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto cend(const _Cp& __c) -> decltype(std::__ndk1::end(__c))
{
    return std::__ndk1::end(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto crbegin(const _Cp& __c) -> decltype(std::__ndk1::rbegin(__c))
{
    return std::__ndk1::rbegin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto crend(const _Cp& __c) -> decltype(std::__ndk1::rend(__c))
{
    return std::__ndk1::rend(__c);
}
# 1936 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/iterator" 3
} }
# 660 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3


# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 1 3
# 158 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 3


namespace std { inline namespace __ndk1 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {

      return !__reference_binds_to_temporary(_Hp, _Tp);



    }

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                      _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__ndk1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__ndk1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__ndk1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__ndk1::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            __value_ = std::__ndk1::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__ndk1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                    _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__ndk1::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            _Hp::operator=(std::__ndk1::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__ndk1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__ndk1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__ndk1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tuple_impl&
    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tuple_impl&
    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__ndk1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};



template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;




    static constexpr bool _EnableImplicitReducedArityExtension = false;


    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};

    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};

    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
        template <class ..._Args>
        static constexpr bool __enable_default() {
            return __all<is_default_constructible<_Args>::value...>::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_explicit() {
            return
                __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                !__tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_implicit() {
            return
               __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }
    };

    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_constructible<_Tuple, tuple>::value
                && __tuple_convertible<_Tuple, tuple>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, tuple>::value
               && !__tuple_convertible<_Tuple, tuple>::value;
        }
    };

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {



        template <class _Tuple>
        using _PreferTupleLikeConstructor = _Or<


            _IsSame<__uncvref_t<_Tuple>, tuple>,
            _Lazy<_And,
                _Not<is_constructible<_Tp..., _Tuple>>,
                _Not<is_convertible<_Tuple, _Tp...>>
            >
        >;

        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                __tuple_convertible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>
            >::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>,
                _Not<__tuple_convertible<_Tuple, tuple>>
            >::value;
        }
    };

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableImplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >;

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableExplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:

    template <bool _Dummy = true, class = typename enable_if<
        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()
    >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    tuple(tuple const&) = default;
    tuple(tuple&&) = default;

    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = _EnableIf<
        _And<
            _IsSame<allocator_arg_t, _AllocArgT>,
           __dependent_type<is_default_constructible<_Tp>, _Dummy>...
       >::value
      >
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      explicit
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp)
                             && !_PackIsTuple
                         >::template __enable_implicit<_Up...>() ||
                        _CheckArgsConstructor<
                            _EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackIsTuple
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 770 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) <= sizeof...(_Tp)
                             && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>() ||
                         _CheckArgsConstructor<
                            !_EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 803 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}
    template <class _Tuple, _EnableExplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableExplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__ndk1::forward<_Tuple>(__t)) {}

    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
        noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(__t.__base_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
        noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
        return *this;
    }

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple&
        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple>::value))
        {
            __base_.operator=(std::__ndk1::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr tuple() noexcept = default;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(tuple&) noexcept {}
};
# 969 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 3
template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((nodebug)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = -1;
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert(value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__ndk1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__ndk1::move(__tup));
}





template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
                     constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::__ndk1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__ndk1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__ndk1::get<_Ip-1>(__x) == std::__ndk1::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__ndk1::get<__idx>(__x) < std::__ndk1::get<__idx>(__y))
            return true;
        if (std::__ndk1::get<__idx>(__y) < std::__ndk1::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef __attribute__((nodebug)) tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef __attribute__((nodebug)) typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef __attribute__((nodebug)) tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return forward_as_tuple(std::__ndk1::forward<_Types>(std::__ndk1::get<_I0>(__t))...,
                                      std::__ndk1::get<_J0>(std::__ndk1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
        typedef __attribute__((nodebug)) typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,
           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,
           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()
                           (forward_as_tuple(
                              std::__ndk1::forward<_Types>(std::__ndk1::get<_I0>(__t))...,
                              std::__ndk1::get<_J0>(std::__ndk1::forward<_Tuple0>(__t0))...
                            ),
                            std::__ndk1::forward<_Tuple1>(__t1),
                            std::__ndk1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef __attribute__((nodebug)) typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__ndk1::forward<_Tuple0>(__t0),
                                            std::__ndk1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__ndk1::forward<_Args1>(std::__ndk1::get<_I1>( __first_args))...),
      second(std::__ndk1::forward<_Args2>(std::__ndk1::get<_I2>(__second_args))...)
{
}
# 1426 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/tuple" 3
} }
# 663 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdexcept" 1 3
# 53 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/stdexcept" 3


namespace std { inline namespace __ndk1 {


class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};


} }

namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{

private:
    std::__ndk1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{

private:
    std::__ndk1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit domain_error(const char* __s) : logic_error(__s) {}


    virtual ~domain_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    virtual ~invalid_argument() noexcept;

};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit out_of_range(const char* __s) : logic_error(__s) {}


    virtual ~out_of_range() noexcept;

};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit range_error(const char* __s) : runtime_error(__s) {}


    virtual ~range_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    virtual ~overflow_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    virtual ~underflow_error() noexcept;

};

}

namespace std { inline namespace __ndk1 {


[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_logic_error(const char*__msg)
{

    throw logic_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_domain_error(const char*__msg)
{

    throw domain_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_invalid_argument(const char*__msg)
{

    throw invalid_argument(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_length_error(const char*__msg)
{

    throw length_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_out_of_range(const char*__msg)
{

    throw out_of_range(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_range_error(const char*__msg)
{

    throw range_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_overflow_error(const char*__msg)
{

    throw overflow_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_underflow_error(const char*__msg)
{

    throw underflow_error(__msg);




}

} }
# 664 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cassert" 1 3
# 20 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cassert" 3
# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/assert.h" 1 3 4
# 72 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/assert.h" 3 4
extern "C" {





void __assert(const char* __file, int __line, const char* __msg) __attribute__((__noreturn__));





void __assert2(const char* __file, int __line, const char* __function, const char* __msg) __attribute__((__noreturn__));

}
# 21 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cassert" 2 3
# 24 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/cassert" 3
# 666 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3

# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 1 3
# 557 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
# 585 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
namespace std { inline namespace __ndk1 {




enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};

typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
# 621 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
typedef enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
} memory_order;



static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
  "unexpected underlying type for std::memory_order");
# 912 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
template <typename _Tp>
struct __cxx_atomic_base_impl {

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    __cxx_atomic_base_impl() noexcept = default;



  constexpr explicit __cxx_atomic_base_impl(_Tp value) noexcept
    : __a_value(value) {}
  _Atomic(_Tp) __a_value;
};



__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) inline
void __cxx_atomic_thread_fence(memory_order __order) noexcept {
    __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) inline
void __cxx_atomic_signal_fence(memory_order __order) noexcept {
    __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> * __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp kill_dependency(_Tp __y) noexcept
{
    return __y;
}
# 1440 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp> >

struct __cxx_atomic_impl : public _Base {






  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __cxx_atomic_impl() noexcept = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr explicit __cxx_atomic_impl(_Tp value) noexcept
    : _Base(value) {}
};



template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __cxx_atomic_impl<_Tp> __a_;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is_lock_free() const volatile noexcept
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator _Tp() const noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __atomic_base() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    __atomic_base(_Tp __d) noexcept : __a_(__d) {}


    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;






};
# 1560 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/atomic" 3
template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __atomic_base() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};



template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}
};



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_init(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_init(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store(atomic<_Tp>* __o, _Tp __d) noexcept
{
    __o->store(__d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange(atomic<_Tp>* __o, _Tp __d) noexcept
{
    return __o->exchange(__d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
                                      _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        _Tp* __e, _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
                                        _Tp __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_add(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) noexcept
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_and(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_or(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) noexcept
{
    return __o->fetch_xor(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    __cxx_atomic_impl<bool> __a_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic_flag() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    atomic_flag(bool __b) noexcept : __a_(__b) {}


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;






} atomic_flag;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __cxx_atomic_thread_fence(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __cxx_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;




} }
# 668 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3
# 673 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3



# 1 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/__undef_macros" 1 3
# 677 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 2 3


namespace std { inline namespace __ndk1 {

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}



template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef __attribute__((nodebug)) typename _Ptr::element_type type;
};



template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef __attribute__((nodebug)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef __attribute__((nodebug)) _Tp type;
};
# 817 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef __attribute__((nodebug)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef __attribute__((nodebug)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef __attribute__((nodebug)) typename _Tp::template rebind<_Up> type;



};



template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef __attribute__((nodebug)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
# 947 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__ndk1::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};



template <class _Tp, class = void>
struct __has_pointer_type : false_type {};

template <class _Tp>
struct __has_pointer_type<_Tp,
          typename __void_t<typename _Tp::pointer>::type> : true_type {};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef __attribute__((nodebug)) typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef __attribute__((nodebug)) _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef __attribute__((nodebug)) typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp, class = void>
struct __has_const_pointer : false_type {};

template <class _Tp>
struct __has_const_pointer<_Tp,
            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef __attribute__((nodebug)) typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{

    typedef __attribute__((nodebug)) typename pointer_traits<_Ptr>::template rebind<const _Tp> type;



};

template <class _Tp, class = void>
struct __has_void_pointer : false_type {};

template <class _Tp>
struct __has_void_pointer<_Tp,
               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef __attribute__((nodebug)) typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{

    typedef __attribute__((nodebug)) typename pointer_traits<_Ptr>::template rebind<void> type;



};

template <class _Tp, class = void>
struct __has_const_void_pointer : false_type {};

template <class _Tp>
struct __has_const_void_pointer<_Tp,
            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef __attribute__((nodebug)) typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{

    typedef __attribute__((nodebug)) typename pointer_traits<_Ptr>::template rebind<const void> type;



};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
__to_raw_pointer(_Tp* __p) noexcept
{
    return __p;
}


template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) noexcept
{
    return std::__ndk1::__to_raw_pointer(__p.operator->());
}
# 1154 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Tp, class = void>
struct __has_size_type : false_type {};

template <class _Tp>
struct __has_size_type<_Tp,
               typename __void_t<typename _Tp::size_type>::type> : true_type {};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef __attribute__((nodebug)) typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::size_type type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment<_Tp,
    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>
        : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef __attribute__((nodebug)) false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_move_assignment<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type {};

template <class _Tp>
struct __has_propagate_on_container_swap<_Tp,
           typename __void_t<typename _Tp::propagate_on_container_swap>::type>
               : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class = void>
struct __has_is_always_equal : false_type {};

template <class _Tp>
struct __has_is_always_equal<_Tp,
           typename __void_t<typename _Tp::is_always_equal>::type>
               : true_type {};

template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal
{
    typedef __attribute__((nodebug)) typename std::__ndk1::is_empty<_Alloc>::type type;
};

template <class _Alloc>
struct __is_always_equal<_Alloc, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::is_always_equal type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef __attribute__((nodebug)) typename _Tp::template rebind<_Up>::other type;
};



template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
    typedef __attribute__((nodebug)) typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
    typedef __attribute__((nodebug)) _Alloc<_Up, _Args...> type;
};
# 1348 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> decltype((void)__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
        is_same<
            decltype(std::__ndk1::__has_allocate_hint_test(declval<_Alloc>(),
                                          declval<_SizeType>(),
                                          declval<_ConstVoidPtr>())),
            true_type>::value>
{
};
# 1381 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Alloc, class _Tp, class ..._Args>
decltype(std::__ndk1::declval<_Alloc>().construct(std::__ndk1::declval<_Tp*>(),
                                           std::__ndk1::declval<_Args>()...),
                                           true_type())
__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
false_type
__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
struct __has_construct
    : integral_constant<bool,
        is_same<
            decltype(std::__ndk1::__has_construct_test(declval<_Alloc>(),
                                          declval<_Pointer>(),
                                          declval<_Args>()...)),
            true_type>::value>
{
};

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
    -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
        is_same<
            decltype(std::__ndk1::__has_destroy_test(declval<_Alloc>(),
                                        declval<_Pointer>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_max_size_test(_Alloc&& __a)
    -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto
__has_max_size_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<bool,
        is_same<
            decltype(std::__ndk1::__has_max_size_test(declval<_Alloc&>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(_Alloc&& __a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<bool,
        is_same<
            decltype(std::__ndk1::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
            true_type>::value>
{
};
# 1492 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef __attribute__((nodebug)) typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef __attribute__((nodebug)) typename _Alloc::difference_type type;
};

template <class _Tp>
struct __is_default_allocator : false_type {};

template <class _Tp>
struct __is_default_allocator<std::__ndk1::allocator<_Tp> > : true_type {};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;
    typedef typename __is_always_equal<allocator_type>::type
                     is_always_equal;


    template <class _Tp> using rebind_alloc =
                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;
    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;







                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return __allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept
        {__a.deallocate(__p, __n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),
                         __a, __p, std::__ndk1::forward<_Args>(__args)...);}
# 1592 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type max_size(const allocator_type& __a) noexcept
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return __select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)
                construct(__a, std::__ndk1::__to_raw_pointer(__begin2), std::__ndk1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        typename enable_if
        <
            (__is_default_allocator<allocator_type>::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__ndk1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                __begin2 += _Np;
            }
        }

    template <class _Iter, class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        void
        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)
                construct(__a, std::__ndk1::__to_raw_pointer(__begin2), *__begin1);
        }

    template <class _SourceTp, class _DestTp,
              class _RawSourceTp = typename remove_const<_SourceTp>::type,
              class _RawDestTp = typename remove_const<_DestTp>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        typename enable_if
        <
            is_trivially_move_constructible<_DestTp>::value &&
            is_same<_RawSourceTp, _RawDestTp>::value &&
            (__is_default_allocator<allocator_type>::value ||
             !__has_construct<allocator_type, _DestTp*, _SourceTp&>::value),
            void
        >::type
        __construct_range_forward(allocator_type&, _SourceTp* __begin1, _SourceTp* __end1, _DestTp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            if (_Np > 0)
            {
                std::__ndk1::memcpy(const_cast<_RawDestTp*>(__begin2), __begin1, _Np * sizeof(_DestTp));
                __begin2 += _Np;
            }
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__ndk1::__to_raw_pointer(__end2-1), std::__ndk1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static
        typename enable_if
        <
            (__is_default_allocator<allocator_type>::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            if (_Np > 0)
                std::__ndk1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer __allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__a.construct(__p, std::__ndk1::forward<_Args>(__args)...);}
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
            {
                ::new ((void*)__p) _Tp(std::__ndk1::forward<_Args>(__args)...);
            }
# 1739 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type __max_size(true_type, const allocator_type& __a) noexcept
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type __max_size(false_type, const allocator_type&) noexcept
            {return numeric_limits<size_type>::max() / sizeof(value_type);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static allocator_type
        __select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static allocator_type
        __select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper
{

    typedef __attribute__((nodebug)) typename _Traits::template rebind_alloc<_Tp> type;



};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator() noexcept {}

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator(const allocator<_Up>&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pointer address(reference __x) const noexcept
        {return std::__ndk1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_pointer address(const_reference __x) const noexcept
        {return std::__ndk1::addressof(__x);}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {
        if (__n > max_size())
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__ndk1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void deallocate(pointer __p, size_type __n) noexcept
        {std::__ndk1::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__ndk1::forward<_Args>(__args)...);
        }
# 1880 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator() noexcept {}

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator(const allocator<_Up>&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_pointer address(const_reference __x) const noexcept
        {return std::__ndk1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
    {
        if (__n > max_size())
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        return static_cast<pointer>(std::__ndk1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void deallocate(pointer __p, size_type __n) noexcept
        {std::__ndk1::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type max_size() const noexcept
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__ndk1::forward<_Args>(__args)...);
        }
# 1981 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(std::__ndk1::addressof(*__x_)) _Tp(__element); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator=(_Tp&& __element)
        {::new(std::__ndk1::addressof(*__x_)) _Tp(std::__ndk1::move(__element)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _OutputIterator base() const { return __x_; }

};

template <class _Tp>
                      __attribute__((__no_sanitize__("cfi")))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
# 2044 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    if (__is_overaligned_for_new(alignof(_Tp)))
        {


            return __r;
        }

        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));


        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__ndk1::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}


template <class _Tp>
struct __attribute__ ((deprecated)) auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) auto_ptr<void>
{
public:
    typedef void element_type;
};


template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __compressed_pair_elem() : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__ndk1::forward<_Up>(__u))
    {
    }

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__ndk1::forward<_Args>(std::__ndk1::get<_Indexes>(__args))...) {}






  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __get() noexcept { return __value_; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __compressed_pair_elem() = default;

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__ndk1::forward<_Up>(__u))
  {}

  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__ndk1::forward<_Args>(std::__ndk1::get<_Indexes>(__args))...) {}







  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __get() noexcept { return *this; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const_reference __get() const noexcept { return *this; }
};


struct __second_tag {};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
  typedef __attribute__((nodebug)) __compressed_pair_elem<_T1, 0> _Base1;
  typedef __attribute__((nodebug)) __compressed_pair_elem<_T2, 1> _Base2;





  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

public:

  template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr __compressed_pair() {}

  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,
                                                   __compressed_pair>::value,
                                          bool>::type = true>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr explicit
  __compressed_pair(_Tp&& __t)
      : _Base1(std::forward<_Tp>(__t)), _Base2() {}

  template <class _Tp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair(__second_tag, _Tp&& __t)
      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}

  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}

  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__ndk1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__ndk1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}
# 2277 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((nodebug)) typename __pointer_type<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };

  typedef __attribute__((nodebug)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((nodebug)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((nodebug)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((nodebug)) = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((nodebug)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__ndk1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__ndk1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__ndk1::forward<_Ep>(__u.get_deleter())) {}


  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(auto_ptr<_Up>&& __p,
             typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                                    is_same<_Dp, default_delete<_Tp> >::value,
                                __nat>::type = __nat()) noexcept
      : __ptr_(__p.release()) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__ndk1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__ndk1::forward<_Ep>(__u.get_deleter());
    return *this;
  }


  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         unique_ptr&>::type
      operator=(auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }
# 2546 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((nodebug)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((nodebug)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((nodebug)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((nodebug)) = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((nodebug)) = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((nodebug)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((nodebug)) = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__ndk1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__ndk1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__ndk1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__ndk1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__ndk1::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__ndk1::forward<_Ep>(__u.get_deleter());
    return *this;
  }






public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}



template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__ndk1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp, class _Dp>



struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result_type operator()(const argument_type& __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr(_Tp*) noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef __attribute__((nodebug)) allocator_traits<_Alloc> __alloc_traits;
public:
    typedef __attribute__((nodebug)) typename __alloc_traits::pointer pointer;
    typedef __attribute__((nodebug)) typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, (void) ++__r)
            ::new (static_cast<void*>(std::__ndk1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new (static_cast<void*>(std::__ndk1::addressof(*__r))) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new (static_cast<void*>(std::__ndk1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, (void) --__n)
            ::new (static_cast<void*>(std::__ndk1::addressof(*__f))) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}
# 3345 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_bad_weak_ptr()
{

    throw bad_weak_ptr();



}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;






    virtual const void* __get_deleter(const type_info&) const noexcept;

private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__ndk1::move(__d)), std::__ndk1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const noexcept;


private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::__ndk1::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(std::__ndk1::move(__a)) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
            : __data_(piecewise_construct, std::__ndk1::forward_as_tuple(__a),
                   std::__ndk1::forward_as_tuple(std::__ndk1::forward<_Args>(__args)...)) {}
# 3569 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* get() noexcept {return std::__ndk1::addressof(__data_.second());}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())
                       noexcept;

    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());


    template<class _Yp>
        shared_ptr(auto_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());







    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
# 3708 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    ~shared_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(const shared_ptr<_Yp>& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr<_Tp>&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(shared_ptr<_Yp>&& __r);

    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr
        >::type&
        operator=(auto_ptr<_Yp>&& __r);
# 3755 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(unique_ptr<_Yp, _Dp>&& __r);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    element_type* operator->() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const noexcept {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    template <class _Dp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        _Dp* __get_deleter() const noexcept
            {return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);}




    template<class ..._Args>
        static
        shared_ptr<_Tp>
        make_shared(_Args&& ...__args);

    template<class _Alloc, class ..._Args>
        static
        shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _Args&& ...__args);
# 3877 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __enable_weak_this(...) noexcept {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};


template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__ndk1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__ndk1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(static_cast<void*>(std::__ndk1::addressof(*__hold2.get())))
            _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__ndk1::addressof(*__hold2.release());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}



template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}




template<class _Tp>
template<class _Yp>

shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,



                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
    __r.release();
}


template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}



template<class _Tp>
template<class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_Args&& ...__args)
{
    static_assert( is_constructible<_Tp, _Args...>::value, "Can't construct object in make_shared" );
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a2, std::__ndk1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    static_assert( is_constructible<_Tp, _Args...>::value, "Can't construct object in allocate_shared" );
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(static_cast<void*>(std::__ndk1::addressof(*__hold2.get())))
        _CntrlBlk(__a, std::__ndk1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = std::__ndk1::addressof(*__hold2.release());
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
}
# 4389 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>
>::type&
shared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}


template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}
# 4514 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__ndk1::swap(__ptr_, __r.__ptr_);
    std::__ndk1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}



template<class _Tp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
make_shared(_Args&& ...__args)
{
    return shared_ptr<_Tp>::make_shared(std::__ndk1::forward<_Args>(__args)...);
}

template<class _Tp, class _Alloc, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    return shared_ptr<_Tp>::allocate_shared(__a, std::__ndk1::forward<_Args>(__args)...);
}
# 4664 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{




    return less<>()(__x.get(), __y.get());


}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    ~weak_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(weak_ptr<_Yp> const& __r) noexcept;



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(weak_ptr<_Yp>&& __r) noexcept;



    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool expired() const noexcept
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}



template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}



template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__ndk1::swap(__ptr_, __r.__ptr_);
    std::__ndk1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}




template <class _Tp> struct owner_less;


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};
# 5213 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}
# 5245 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);




class __attribute__ ((__visibility__("default"))) __sp_mut
{
    void* __lx;
public:
    void lock() noexcept;
    void unlock() noexcept;

private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __attribute__ ((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__ ((__visibility__("default")))
__sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>

shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return atomic_load(__p);
}

template <class _Tp>

void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}

template <class _Tp>

shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template <class _Tp>

bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::__ndk1::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::__ndk1::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}
# 5419 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
struct __attribute__ ((__visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer_safety() : __v_() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator int() const {return __v_;}
};
# 5446 "/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/c++/v1/memory" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}




__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);


template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)

    noexcept



{
    __swap_allocator(__a1, __a2,
      integral_constant<bool, std::__ndk1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)

    noexcept



{
    using std::__ndk1::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value



        && is_nothrow_move_assignable<_Alloc>::value

    > {};



template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __attribute__((__no_sanitize__("cfi")))
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),
                         std::__ndk1::forward<_Args>(__args)...);
    }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };


template<typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template<typename _Alloc>
struct __is_allocator<_Alloc,
       typename __void_t<typename _Alloc::value_type>::type,
       typename __void_t<decltype(std::__ndk1::declval<_Alloc&>().allocate(size_t(0)))>::type
     >
   : true_type {};





struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

    constexpr explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void* p) const noexcept {
        std::__libcpp_deallocate(p, __size_, __align_);
    }

   private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
      return __holder_t(std::__libcpp_allocate(__s, __align),
                     __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void* __p, size_t __s,
                                 size_t __align) noexcept {
      std::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static __holder_t __allocate_type(size_t __n) {
      return __allocate_bytes(__n * sizeof(_Tp), alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static void __deallocate_type(void* __p, size_t __n) noexcept {
      __deallocate_bytes(__p, __n * sizeof(_Tp), alignof(_Tp));
  }
};


} }
# 7 "/Users/bytedance/code/my/LiveStream/AndroidPublisher/rtmplive/src/main/cpp/FLVTag.cpp" 2

FLVTag::FLVTag(
        uint8_t tag_type,
        uint32_t data_size,
        uint32_t time_stamp,
        IFLVTagData* data
): tag_type_(tag_type), data_size_(data_size), time_stamp_(time_stamp),data_(data)
{
    int i = 0;
    buffer_[i++] = tag_type;

    buffer_[i++] = (data_size >> 16) & 0xFF;
    buffer_[i++] = (data_size >> 8) & 0xFF;
    buffer_[i++] = (data_size) & 0xFF;

    buffer_[i++] = (time_stamp >> 16) & 0xFF;
    buffer_[i++] = (time_stamp >> 8) & 0xFF;
    buffer_[i++] = (time_stamp) & 0xFF;
    buffer_[i++] = (data_size >> 24) & 0xFF;

    buffer_[i++] = 0;
    buffer_[i++] = 0;
    buffer_[i++] = 0;

    size_ = i;
}

FLVTag::~FLVTag() {
}

char *FLVTag::WriteTo(char *output) {
    memcpy(output, buffer_, size_);
    output += size_;
    return data_->WriteTo(output);
}

int FLVTag::Size() {
    return size_ + data_->Size();
}
